# Thread
기존의 배운 방식에 의하면 하나의 실행 흐름(thread)를 가지고 있는 프로세스들을 fork() 함으로써
</br> CPU에서 PCB를 Context Switch를 함으로써 동시성 처리를 하도록 만들었다</br>
하지만 멀티프로세싱을 하는 경우에는 데이터 공유를 위해서 메모리 공유나 메세지 전달 방식을 OS에게 부탁해서 진행했어야 하는 번거러움이 존재헀다</br>
그래서 생각한 것이 프로세스내에 존재하는 하나의 thread를 여러개로 나눠서 진행하자는 것이다</br>

## Thread란...
- `lightweight process` 
- `cpu 사용률의 기본단위`
- `별도의 threadID, Program Counter, register set, stack를 가진다`

![thread](./img/Thread-concept.png)

쉬운 이해를 위해서는 우리가 흔히 사용하는 웹서버를 생각하면 된다</br>
웹서버에는 새로운 사용자가 들어올때마다 새로운 쓰레드를 생성함으로써 다중 사용자를 처리할 수 있다</br>

### 장점
- `응답성` : multi thread를 통하여 non-blocking을 구현할 수 있다
- `자원 공유` : `data` `code` `files`영역을 공유함으로써 통신을 따로 할필요가 없다
- `경제성` : 프로세스를 새로 생성하는 것보다 적은 비용이 든다
- `확장성` : multiprocessor 아키텍쳐의 이점을 이용할 수 있다

## Multicore Programming
요즘 프로세서에는 하나의 cpu에 코어가 여러개 존재함으로써</br>
하나의 코어에 하나의 쓰레드를 작동함으로써 병렬처리가 가능해졌다</br>
여러개의 코어를 이용하는 것이 multicore programming으로 보면 된다</br>

- `singlecore` : time sharing을 이용하여 쓰레드를 사이사이에 끼워넣는다
- `multicore` : 코어수 만큼 쓰레드를 배치해주고 그래도 쓰레드가 생성된다면 time sharing을 이용한다

### 코어가 많으면 많을 수록 성능이 좋을까?
멀티 코어를 사용하니깐 당연히 속도가 싱글 코어에 비해서는 빠르다</br>
하지만 2개라고 해서 1개에 비해서 2배가 빠른것은 아니다</br>
왜냐하면 모든 데이터가 완벽히 병렬처리가 가능한 데이터들이 아니기 때문이다</br>
분명히 일부의 데이터는 순차적으로 처리해야만 하는 데이터가 조금이라도 존재한다</br>
이 순차적으로 처리해야하는 데이터로 인해 코어가 많다고 해서 속도가 이상적으로 빨라지지는 못한다