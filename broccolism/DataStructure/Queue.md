# 선입선출!

이번에는 진짜 선입선출 자료구조이다. 먼저 들어간 데이터가 먼저 나온다. 터널같은 자료구조다.
스택은 LIFO(Last In First Out), 큐는 FIFO(First In First Out)라고 볼 수 있다.

### What for?

큐는 어디에 쓰일 수 있을까?

- 가장 쉽게 접할 수 있는 예시로는 "줄 서기"가 있다.
  - 은행이나 병원에서 먼저 번호표를 뽑은 사람이 먼저 대기열에서 나간다.
    - 이 때, 누가 나갈 차례인지와 누가 들어오는지는 완전히 별개의 이벤트로 발생한다.
- 또한 순서가 유지되어야 할 때 주로 쓰인다.
  - 프린트의 출력 처리
  - 프로세스 관리

# ADT

| 이름    | 동작                                                                       |
| ------- | -------------------------------------------------------------------------- |
| front   | 큐의 앞부분을 가리킨다. 즉, 데이터가 입력되는 곳을 의미한다.               |
| rear    | 큐의 뒷부분 즉, 데이터가 삭제되는 곳을 의미한다.                           |
| init    | 큐의 초기화를 진행한다. 큐 생성 후 제일 먼저 호출되어야 한다.              |
| isEmpty | 큐가 비어있는지 아닌지 확인한다.                                           |
| enqueue | 큐에 데이터를 저장한다.                                                    |
| dequeue | 가장 먼저 저장했던 데이터, 즉 front에 해당하는 데이터를 삭제하고 반환한다. |
| peek    | 가장 먼저 저장했던 데이터가 무엇인지 반환한다.                             |

스택에서와 마찬가지로, dequeue 시에는 데이터를 삭제할뿐만 아니라 return까지 해주어야 한다. 데이터를 뺐으니 지워지는 것이고, 지웠으니 빠지는 것이다.

# 구현

큐 역시 스택과 마찬가지로, 두가지 자료구조를 활용해서 만들 수 있다.

1. 순차 리스트 (배열)
2. 링크드리스트
   왠지 1번이 더 간단할 것 같지만, 사실은 그렇지 않다. 배열을 써서 구현할 경우 고려해야 할 점이 훨씬 많다. 그러니 링크드 리스트 기반 큐의 구현을 먼저 알아보자.

### 1) 링크드리스트 기반 구현

- 링크드리스트로 스택도 구현할 수 있다. 큐를 구현할 때에는 스택을 구현했던 것과 매우 유사하게 만들면 된다. 사실 스택에서 조금만 수정하면 큐를 만들 수 있다. 달라진 점은 데이터가 입력되는 위치밖에 없기 때문이다.

  - 스택은 push, pop이 모두 같은 곳에서 이루어지지만
  - 큐는 enqueue, dequeue가 다른 곳에서 이루어진다.

- 이 때 노드와 큐 구조체는 아래와 같이 정의한다.

```C++
typedef struct NodeStruct {
  DataType data;
  NodeStruct *next;
} Node;

typedef struct QueueStruct {
  Node *front;
  Node *rear;
}
```

- enqueue할 때는 rear 기준, dequeue할 때는 front 기준으로 하면 된다.

### 2) 배열 기반 구현

- 배열 기반으로 구현할 때에는 1. 엄청 비효율적인 방식을 쓰거나 2. 조금 신경을 써서 약간 효율적인 "것처럼 보이는" 방식을 쓰거나 3. 조금 더 신경을 써서 효율적인 방식을 사용할 수 있다.

- 공통점은 모두 1차원 배열을 사용한다는 점이다.

1. 엄청 비효율적인 방식

- 큐를 1차원 배열로 보고 삽입, 삭제를 할 때마다 리스트 내의 나머지 원소를 밀거나 당긴다.
  - 따라서 삽입, 삭제 연산은 O(N) 시간이 걸린다.
  - 하지만 이렇게하면 앞쪽에 공간이 남아있음에도, 배열의 마지막 칸까지 값을 채웠다면 새로운 값을 삽입하지 못하는 문제가 발생한다.
    - 동작은 하지만, 최대 저장할 수 있는 데이터 갯수는 결국 배열의 길이가 되어버린다.

2. 약간 효율적인 것처럼 보이는 방식

- 큐를 1차원 배열로 보고 삽입, 삭제를 할 때마다 `front`, `rear`만 움직인다.
  - 하지만 여전히 1번과 같은 문제가 발생한다.

3. 효율적인 방식

- 큐를 원형으로 보고 삽입, 삭제를 할 때마다 `front`, `rear`만 움직인다.
  - 이렇게 하면 큐가 비었을 때와 가득 찼을 때 구분을 쉽게 할 수 있을뿐만 아니라
  - 배열의 마지막에 가더라도 원소를 계속해서 넣을 수 있다.
  - 이런 큐를 Circular Queue라고도 한다.
    ![circular queue](https://media.geeksforgeeks.org/wp-content/uploads/Circular-queue.png)
  - 이 때 주의할 점은, 큐의 `front`에 바로 값을 넣는 것이 아니라 그 다음칸부터 넣는 것이다.
    - 그렇지 않으면 큐가 텅 비었을 때와 가득 찼을 때 구분할 수가 없다.

### 비교

- 링크드리스트를 이용하면 구현이 편하고, 큐의 사이즈를 동적으로 바꿀 수 있다.
- 배열을 이용하면 구현은 복잡하지만, 사이즈가 고정되어야 하는 큐를 효율적으로 만들 수 있다.
