# 선입선출!

이번에는 진짜 선입선출 자료구조이다. 먼저 들어간 데이터가 먼저 나온다. 터널같은 자료구조다.
스택은 LIFO(Last In First Out), 큐는 FIFO(First In First Out)라고 볼 수 있다.

### What for?

큐는 어디에 쓰일 수 있을까?

- 가장 쉽게 접할 수 있는 예시로는 "줄 서기"가 있다.
  - 은행이나 병원에서 먼저 번호표를 뽑은 사람이 먼저 대기열에서 나간다.
    - 이 때, 누가 나갈 차례인지와 누가 들어오는지는 완전히 별개의 이벤트로 발생한다.
- 또한 순서가 유지되어야 할 때 주로 쓰인다.
  - 프린트의 출력 처리
  - 프로세스 관리

# ADT

| 이름    | 동작                                                                       |
| ------- | -------------------------------------------------------------------------- |
| front   | 큐의 앞부분을 가리킨다. 즉, 데이터가 입력되는 곳을 의미한다.               |
| rear    | 큐의 뒷부분 즉, 데이터가 삭제되는 곳을 의미한다.                           |
| init    | 큐의 초기화를 진행한다. 큐 생성 후 제일 먼저 호출되어야 한다.              |
| isEmpty | 큐가 비어있는지 아닌지 확인한다.                                           |
| enqueue | 큐에 데이터를 저장한다.                                                    |
| dequeue | 가장 먼저 저장했던 데이터, 즉 front에 해당하는 데이터를 삭제하고 반환한다. |
| peek    | 가장 먼저 저장했던 데이터가 무엇인지 반환한다.                             |

스택에서와 마찬가지로, dequeue 시에는 데이터를 삭제할뿐만 아니라 return까지 해주어야 한다. 데이터를 뺐으니 지워지는 것이고, 지웠으니 빠지는 것이다.

# 구현

큐 역시 스택과 마찬가지로, 두가지 자료구조를 활용해서 만들 수 있다.

1. 순차 리스트 (배열)
2. 링크드리스트
   왠지 1번이 더 간단할 것 같지만, 사실은 그렇지 않다. 배열을 써서 구현할 경우 고려해야 할 점이 훨씬 많다. 그러니 링크드 리스트 기반 큐의 구현을 먼저 알아보자.

### 1) 링크드리스트 기반 구현

- 링크드리스트로 스택도 구현할 수 있다. 큐를 구현할 때에는 스택을 구현했던 것과 매우 유사하게 만들면 된다. 사실 스택에서 조금만 수정하면 큐를 만들 수 있다. 달라진 점은 데이터가 입력되는 위치밖에 없기 때문이다.

  - 스택은 push, pop이 모두 같은 곳에서 이루어지지만
  - 큐는 enqueue, dequeue가 다른 곳에서 이루어진다.

- 이 때 노드와 큐 구조체는 아래와 같이 정의한다.

```C++
typedef struct NodeStruct {
  DataType data;
  NodeStruct *next;
} Node;

typedef struct QueueStruct {
  Node *front;
  Node *rear;
}
```

- enqueue할 때는 rear 기준, dequeue할 때는 front 기준으로 하면 된다.
