# What for

1. 같은 타입의 데이터가
2. 하나가 아닌 여러개
3. 동시에 관리되어야 할 때
4. 또한, 그 데이터들 간 hierarchy가 없을 때
   리스트 자료 구조를 사용한다.

# 2가지 리스트 비교

| 구분      | Sequential List                                                     | Linked List                                                                  |
| --------- | ------------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| 메모리    | 정적 할당                                                           | 동적 할당                                                                    |
| 사이즈    | 고정                                                                | 유동적                                                                       |
| 접근      | 인덱스로 바로 접근                                                  | `next` 포인터로 순차적 접근                                                  |
| 삽입      | 값을 추가한 후 다음 데이터들 뒤로 밀기: O(N)                        | 메모리 할당 후 기존 노드와 연결: O(1)                                        |
| 삭제      | 값만 삭제한 후 다음 데이터들 앞으로 끌어오기: O(N)                  | 기존 노드와 연결 해제 후 메모리 해제: O(1)                                   |
| 장점 비교 | 저장된 값에 바로 접근 가능: O(1)                                    | 메모리 효율적으로 활용 가능 + 노드의 중간 지점에서도 O(1)만에 추가/삭제 가능 |
| 단점 비교 | 할당된 메모리 크기가 고정적, 배열의 중간 지점에서 추가/삭제 시 O(N) | 저장된 값에 바로 접근 불가: O(N)                                             |

# Linked List

### Simple Linked List

![image](https://upload.wikimedia.org/wikipedia/commons/thumb/9/9c/Single_linked_list.png/800px-Single_linked_list.png)

- 링크드리스트의 가장 단순한 구조.
- head를 갖고 있고, 각 노드에 자료 공간과 포인터 공간이 각각 하나씩 있다.
  - 각 노드의 포인터는 다음 노드를 가리킨다.
  - 마지막 노드의 포인터는 `NULL` 값을 갖는다.
    - 따라서 검색 및 삭제 연산을 구현할 때 NULL값을 항상 체크해줘야 한다.
- head 노드 다음에 더미 노드를 추가해서 사용하면 구현이 수월해진다.
  - 예외처리를 해야 하는 경우의 수가 줄어들기 때문이다.

### Doubly Linked List

![image](https://upload.wikimedia.org/wikipedia/commons/thumb/c/ca/Doubly_linked_list.png/800px-Doubly_linked_list.png)

- Next 노드만 알 수 있는 simpled linked list와는 달리, Prev 노드도 알 수 있도록 포인터 공간이 하나 늘었다.
- head를 갖고 있고, 각 노드에 자료 공간 하나와 포인터 공간 2개가 존재한다.
  - Prev 포인터가 있음으로써 생기는 장점 (vs. simple linked list)
    - 역순 탐색이 빨라진다.
      - 이를 이용해서 리스트 안에 들어가있는 자료형의 순서에 관한 규칙을 알고 있다면 절반은 head에서, 나머지 절반은 tail에서 탐색하는 등 새로운 기법을 사용할 수 있다.
    - 손상에 강한 편이다.
      - 노드 하나를 가리키는 포인터가 총 2개이기 때문에 한쪽과 연결이 끊어졌다고 해서 영원히 해당 노드에 접근할 수 없게 되지 않는다.
    - 삭제 연산이 훨씬 간단하게 구현된다.

### Circular Linked List

![image](https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Circurlar_linked_list.png/800px-Circurlar_linked_list.png)

- simple linked list에서 마지막 노드가 head를 가리키게 만든 링크드리스트.
  - 마지막 포인터가 NULL이 아닌 일반 노드를 가리키고 있기 때문에 구현이 훨씬 편해진다.
  - 따라서 어떤 노드에서든 다른 노드로 자유롭게 접근할 수 있다.
- head와 tail 구분이 없고, 각 노드에 자료 공간과 포인터 공간이 각각 하나씩 있다.
- 주로 순서를 표현해야할 때 사용된다.
  - Round Robin 기법 구현 시
  - 스트림 버퍼 구현 시
  - 멀티플레이어 게임에서 누구 턴인지 트랙킹 할 시
- 큐 구현에도 적합하다.

# 결론

### 순차리스트

- 장점
  - 검색 속도가 O(1)이다. (인덱스로 접근하기 때문!)
- 단점
  - 첫번째나 가운데에 데이터를 추가/삭제할 때 O(N)의 시간이 걸릴 수 있다.
  - 크기가 고정적이다.

### 링크드리스트

- 장점
  - 첫번째 데이터 및 가운데 데이터의 추가/삭제가 O(1)만에 수행된다.
  - 크기가 유동적이다.
- 단점

  - 검색에 매우 취약하다.

∴ 탐색 또는 정렬을 자주 하면 순차리스트(배열)을, 추가 또는 삭제를 자주 하면 링크드리스트를 사용하는 것이 유리하다.
