## 3장 - 컴퓨터 시스템의 동작 원리 (~12. 시스템 콜을 이용한 입출력 수행)
### DMA
---
![image](https://user-images.githubusercontent.com/59992230/105498707-d84ad500-5d03-11eb-8a0d-151b44eb7431.png)
(*사진은 저자 교수님의 KMOOC 강의)
- 메모리는 CPU에서만 접근 가능한 장치다. 메모리 접근 연산이 필요할 때 CPU에 interrupt를 보내서 대행하는 식의 처리를 진행한다. 이렇게 매 자잘한 접근마다 CPU의 처리를 요청한다면 프로그램을 실행하던 CPU의 효율성이 떨어진다. 
- 그래서 메모리에게도 작은 cpu 역할을 하는 **DMA(Direct Memory Access)** controller를 두어 CPU의 역할을 분담한다.
- DMA가 직접 메모리에 접근한다는 의미보다는, 메모리로 보내려는 데이터를 작은 Byte 단위가 아닌 큰 Block 단위로 읽어오고,  작업 수행이 다 되었다고 CPU에게 interrupt를 보낸다. 메모리 접근 연산으로 인한 interrupt의 빈도를 줄여서 CPU를 좀 더 효율적으로 사용할 수 있게 한다.

### 저장장치
---
- 보조기억장치는 **file system**과 **swap area**로 구분  
- 프로그램 수행에 당장 필요한 부분은 메모리에, 나머지는 디스크의 swap area에 swap out 시키는 형태로 활용
- file system은 비휘발성을 활용한다면, swap area는 메모리의 연장공간으로 활용하는 것

- 계층구조
![image](https://user-images.githubusercontent.com/59992230/105499541-f8c75f00-5d04-11eb-8ff3-55dcb850172f.png)

>**캐싱기법**?
>상위 계층으로 갈수록 접근 속도가 월등히 빨라지나, 용량은 상대적으로 적다. 하지만 필요한 정보만 선별적으로 저장해둔다면?
>책장을 정리한다고 생각해보자. 팔이 잘 닿는 곳보다 수그리거나 의자에 올라가야 닿을 수 있는 공간이 더 넓을 것이라고 가정한다면, 닿기 쉬운 곳엔 무엇을 두어야할까. 그야 물론 자주 쓰이는 책들일 것이다. 이처럼 저장장치에서 빈번히 사용되는 정보를 선별 저장하는 기법을 의미한다. 이를 토대로 적은 적장공간으로 평균 성능 향상 가능하다.

### 보안
---
**하드웨어 보안**
- 다른 프로그램의 실행 방해 or 프로그램간 충돌 문제 막아야함
- OS에서는 이를 위해 중요 명령을 수행할 수 있는 커널모드(kernel mode, system mode)와 사용자모드(user mode)로 구분하여 권한 부여
- 그러나 OS가 아니라 CPU에서 실행될때에는 모드로 권한 판단이 어려움, 그래서 CPU 내부에 **모드비트(mode bit)**를 설정
- 0: 커널모드, 1: 사용자모드
- 보안 명령 수행하기 전에는 mode bit을 조사해서 값이 0으로 세팅되어 있을때만 실행, OS에게 점유권을 넘기고 커널모드로 실행
- 이후에 OS-> CPU로 제어권을 넘길땐 모드비트 1으로 전환해줌
- interrupt 발생시 mode bit 0으로 자동 세팅, 결국 특권 명령은 OS만 실행 가능

**메모리 보안**
- 사용자 프로그램이 타 프로그램 or OS의 메모리 영역 참조하지 못하게 방지
- 2개의 register를 사용하여 프로그램이 접근하려는 메모리 부분이 합법적인지 체크
-
 ![image](https://user-images.githubusercontent.com/59992230/105503634-2e227b80-5d0a-11eb-96c8-3313a65bc4d9.png)
![image](https://user-images.githubusercontent.com/59992230/105503648-324e9900-5d0a-11eb-97fe-fc0b4b5b8bc5.png) 
- **base register**: 어떤 프로그램이 수행되는 동안 그 프로그램이 합법적으로 접근할 수 있는 메모리상의 가장 작은 주소 (**시작주소**)
- **limit register**:  그 프로그램이 base register부터 접근할 수 있는 메모리의 범위 (**길이**)
- 접근하려는 주소가  base < address < base + limit 인지 확인, 아닐시 interrupt 발생 후 강제종료
- 두 register의 지정은 OS의 특권명령으로 셋팅
> *여기서는 한 프로그램이 메모리 한 영역 안에 연속적으로 위치할 때의 경우*를 말한다. 메모리의 여러 영역에 나뉘어 위치하는 paging은 7장에서 다룸


**CPU 보호**
- 특정 프로그램이 CPU 사용 권한을 독점하는걸 방지하기 위한 **timer** 존재
- CPU 점유 일정 시간 경과 -> timer에서 interrupt 발생 -> handler: CPU를 타 프로그램에게 이양
- timer는 일정 시간 단위로 세팅 가능(OS에서 load timer)하며, 매 clock tick마다 1씩 감소하고 0이 될때 interrupt 발생

**입출력 수행**
- 사용자 프로그램에서 입출력 명령을 수행시킬 땐 system call로 interrupt를 발생시켜 OS의 커널모드에서 특권명령으로 실행해야하며, 사용자 프로그램은 직접 수행하지 못한다. 