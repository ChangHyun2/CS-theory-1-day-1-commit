### 인증이란 ?

> 서버에 엑세스하고 있는 사람이 누군지 알려면 상대방 클라이언트에 정보를 요청해야 한다. 시스템에 엑세스하는 권한을 가지고 있는 본인인지 아닌지를 확인하기 위해서는 등록된 본인만이 알고 있는 정보 또는 등록한 본인만이 가지고 있는 정보 등으로 확인해야 한다. 단 상대가 가짜라 하더라도 복인 확인을 하기 위한 정보를 제시할 수 있으면 본인으로 인식한다.

#### 1. BASIC 인증

> 웹 서버와 대응하고 있는 클라이언트 사이에서 이뤄지는 인증방식이다. 

BASIC 인증이 필요한 리소스에 리퀘스트가 있을 경우에는 서버는 상태 코드401와 함께 인증의 방식과 Request-URI의 보호 공간을 식별하기 위한 문자열을 Authenticate 헤더 필드에 포함해서 리소스를 반환한다. 클라이언트는 ID와 패스워드를 콜론으로 연결한 문장을 Base64이라 불리는 형식으로 헤더필드에 포함해서 리퀘스트를 송신한다. 인증 정보가 정확하면 Request-URI 리소스를 포함한 리스폰스를 반환한다.

#### 2. DIGEST 인증

> 챌린지 리스폰스 방식이 사용되고 있어 패스워드를 있는 그대로 직접 보내는 일은 없다. 챌린지 리스폰스는 최초에 상대방에게 인증 요구를 보내고, 상대방측에서 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산해, 상대에게 송신하여 인증하는 방식이기 때문에 패스워드가 누출될 가능성이 줄어든다. 

인증이 필요한 리소스에 리퀘스트가 있을 경우에는 서버는 상태 코드 401 Authorization Requird 와 함께 챌린지 리스폰스 방식의 인증에 필요한 챌린지 코드를 헤더 필드에 포함해서 리스폰스를 반환한다. 헤더 필드에 반드시 포함되어야 하는 정보는 realm 과 none 두개이다. 클라이언트는 nonce는 401 리스폰스를 반환할 때마다 생성되는 유일한 문자열이다. 
상태 코드 401을 수신한 클라이언트는 DIGEST 인증을 위해 필요한 정보를 Authorization 헤더 필드에 반드시 포함되어야 하는 정보는 username, realm, nonce, uri, response 를 사용한다. 서버는 인증 정보가 정확한 것인지 아닌지를 판단합니다. 

#### 3. SSL 클라이언트 인증

> 유저 ID와 패스워드를 사용한 인증 방식은 이 두 가지 정보가 정확하다면 본인으로서 인증할 수 있습니다. 그러나 이 정보가 도난당하여 제3자로부터 위장을 방지하기 위한 대책중의 하나이다.

서버는 리퀘스트가 있을 경우에 클라이언트 증명서를 요구하는 Certificate Request 라는 메세지를 송신한다. 유저는 클라이언트 증명서를 송신한다. 서버는 증명서를 검증하여 검증 결과가 정확하다면 클라이언트의 공개키를 취득한다. 

##### 3-1 SSL 클라이언트 인증은 2-factor 인증에서 사용

대부분의 경우 단독으로 사용되지는 않고, 이후에 다룰 폼 베이스 인증과 합쳐서 2-factor 인증의 하나로서 이용되고 있다. 이용자가 가진 패스워드라는 한 개의 요소만이 아닌 이용자가 가진 다른 정보를 병용해서 인증을 하는 방법이다. 

#### 4. 폼 베이스 인증

>  HTTP 프로토콜로서 사양이 정의되어 있는 방식은 아니지만, 클라이언트가 서버 상의 웹 애플리케이션에 자격정보를 송신하여 그 자격 정보의 검증 결과에 따라 인증을 하는 방식이다. 웹 사이트의 인증 기능으로서 요구되는 기능의 레벨을 충족시킨 표준적인 것이 존재하지 않기 때문에 웹 애플리케이션에서 제각각 구현하는 폼 베이스 인증을 채용하는 수 밖에 없다. 공통 사양이 결정되어 있지 않은 폼 베이스 인증에서는 웹 사이트 별로 다르게 구현을 하고 있다.

클라이언트와 서버에 유저 ID나 패스워드 등의 자격 정보를 포함한 리퀘스트를 송신한다. 보통은 POST 메소드가 사용되어 엔티티 바디에 자격 정보를 저장한다. 서버 측은 유저를 식별하기 위해서 세션 ID를 발행한다. 유저의 인증 상태를 세션 ID와 연관지어 서버 측에 기록한다. 

##### 4-1 세션 관리와 쿠키에 의한 구현

HTTP는 스테이트리스 프로토콜이기 때문에 방금 전에 인증을 성공했던 유저라는 상태를 프로토콜 레벨에서는 유지할 수 없다. 다음에 그 유저가 액세스했다고 하더라도 다른 유저와 구별할 수 없어 세션관리와 쿠키를 사용해 상태관리 한다. 세션 ID는 이른바 정리권 번호로 다른 유저와 구별하기 위한 것이다. 서버 측에서는 유효 기한을 관리하는 등 보안을 유지할 필요가 있다.
또한 서버 측에서 세션 ID를 받은 클라이언트는 쿠키로 저장해 둡니다. 다음번에 서버에 리퀘스트를 송신하는 때에는 브라우저가 자동으로 쿠키를 송출하기 때문에 세션 ID가 서버에 송신된다. 

##### 4-2 폼베이스 인증 약점

일반적으로 패스워드를 salt라는 부가 정보를 사용해서 해시라는 알고리즘으로 계산한 값을 저장하지만, 평문의 패스워드를 서버에 그대로 보존하는 경우도 있지만 누설되어 버릴 위험이 있다.

