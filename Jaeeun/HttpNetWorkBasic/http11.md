### 1. HTTP의 약점

#### 1-1 평문이기 때문에 도청이 가능

HTTP 자신을 암호화하는 기능이 없기 때문에 통신 전체가 암호화 되지는 않는다. TCP/IP 구조의 통신 경로 내용은 전부 도중에 엿볼 수 있기 때문이다. 암호화 통신은 메세지 속의 의미는 모르지만 암호화 된 내용 자체는 볼 수 있기 때문에 문제가 된다.
같은 세그먼트 통신을 도청하는 것은 어려운 것도 아니다. 네트워크 상을 흐르고 있는 패킷을 수집하는 것만으로도 도청할 수 있다. 도청으로부터 지키기 위해 암호화 방법을 사용하고 있다.

`통신 암호화` : SSL 이나 TLS 라는 다른 프로토콜을 조합함으로써 HTTP 통신 내용을 암호화할 수 있다. SSL등을 통해 안전한 통신로를 확립하고 나서 그 통신로에서 통신한다. 이것을 HTTPS 라고 부른다.

`콘텐츠 암호화` : 통신하고 있는 콘텐츠의 내용 자체를 암호화해 버리는 방법이다. 물론 콘텐츠의 암호화를 유효하게 하기 위해서는 클라이언트와 서버가 컨텐츠의 암호화나 복호화 구조를 가지고 있는 것이 전제이다. 

#### 1-2 통신 상대를 확인하지 않기 때문에 위장이 가능

HTTP 통신은 상대를 확인하지 않기 때문에 URI에서 지정된 호스트인지, 아닌지 모른다는 것이다. 그렇기 때문에 누구나 리퀘스트 할 수 있다. SSL로 상대를 확인할 수 있는 증명서를 제공한다. 증명서는 신뢰할 수 있는 제3자 기관에 의해 발행되는 것이기 때문에 서버나 클라이언트가 실재하는 사실을 증명한다. 그 증명서를 위조하는 것은 기술적으로 어렵기 때문에 내가 통신하고자 하는 상대인지 아닌지를 판단할 수 있다.

#### 1-3 완전성을 증명할 수 없기 때문에 변조 가능

완전성이란 정보의 정확성을 가리킨다. 만약 상대가 수신할 때까지의 사이에 변조되었다고 하더라도 이 사실을 알 수 없다. 예를 들어 어떤 웹사이트에서 다운로드 했다고 하면 클라이언트에 다운로드한 파일과 서버상에 있는 파일이 다른지 같은지 알 수 없다. HTTP를 사용해서 완전성을 확인하기 위한 방법은 있지만, MD5 또는 SHA-1 등의 해시값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 있다. 파일 다운로드 서비스를 제공하고 있는 웹사이트에서는 PGP(Pretty Good Privacy)에 의한 서명과 MD5에 의한 해시값을 제공한다. 하지만 이 방법으로도 확실히 알 수 없다.

### 2. HTTP + 암호화 + 인증 + 완전성 보호 = HTTPS

> 위의 약점들을 보완하기 위해서 암호화, 인증 등의 구조를 더한 것을 HTTPS(HTTP Secure) 이다. 웹페이지의 로그인이나 쇼핑의 결제화면 등에서 사용되고 있다. `http://` 가 아닌 `https://` 를 사용한다. (자물쇠 마크가 표시되는 등 HTTP와는 다르게 표시되는 경우가 있다.)

#### 2-1 SSL의 껍질을 덮어쓴 HTTP

소켓 부분을 SSL(Secure Socket Layer) 이나 TLS(Transfer Layer Security) 라는 프로토콜로 대체한 것이다. SMTP 나 Telnet 등에서도 이용될 수 있고 SSL은 현재 세계 어느 곳에서도 널리 사용되고 있는 네트워크 보안 기술이라고 말할 수 있다.

#### 2-2 상호간에 키를 교환하는 공개키 암호화 방식

암호화와 복호화에 하나의 키를 사용해서 키를 가지고 있는 누구라도 암호를 풀 수 가 있다는 문제점이 있다. 공통키 암호의 문제를 해결하려고 한것이 공개키 암호라는 방식이다. 공개키 암호에서는 서로 다른 두개의 키페어를 사용한다. 암호를 보내는 측이 상대의 공개키를 사용해 암호화한다. 암호화된 상대는 자신의 비밀키를 사용해 복호화 한다. HTTP는 공통키 암호화와 공개키 암호의 양쪽 성질을 가진 하이브리드 암호 시스템이다. 키를 안전하게 교환할 수 있는 공개키 암호만을 사용해서 통신해도 괜찮다고 생각하지만, 공개키 암호는 공통키 암호에 비해서 속도가 느리다. 그렇기 때문에 키를 교환하는 곳에서는 공개키를 사용하고 그 후의 통신에서는 공통키 암호를 사용한다.

#### 2-3 공개키가 정확한지 아닌지를 증명하는 증명서

공개키가 진짜인지 아닌지 증명할 수 없다는 문제점이 있다. 이 문제를 해결하는 데는 인증 기관(CA:Certification Authority)가 있다. 인증 기관이란 클라이언트와 서버가 모두 신뢰하는 제3자 기관이다. 먼저 서버의 운영자가 인증 기관에 공개키를 제출한다. 인증 기관은 공개키에 디지털 서명을 하고 서명이 끝난 공개키를 만든다. 그리고 공개키 인증서에 서명이 끝난 공개키를 담는다. 서버는 이 인증 기관에 의해 작성된 공개키 인증서를 클라이언트에게 보낸다. 

`EV SSL` : **상대방이 실제로 있는 기업인지를 확인하는 역할**은 EV SSL이라고 한다. 세계 표준의 인정 가이드라인에 의해서 발행되는 증명서이다. 운영하는 조직의 실재성을 확인하는 방법을 엄격히 규정하고 있기 때문에 웹 사이트의 신뢰성을 더욱 높일 수 있다. (브라우저의 주소창의 색이 녹색으로 변하면 EV SSL 증명서로 증명된 웹사이트) 

`클라이언트 확인하는 증명서` : 서버가 통신하고 있는 상대가 의도한 클라이언트인 것을 증명하는 클라이언트 인증을 할 수 있다. 클라이언트 증명서에서 문제가 되는 점은 증명서의 입수와 배포이다. 클라이언트 증명서는 유로로 구입할 필요가 있기 때문에 유저 수만큼 비용이 증가한다. 그렇기 때문에 클라이언트 인증은 그 만큼 비용을 들일 필요가 있는 곳에서만 사용되고 있다.

`자기 인증 기관 발행 증명서` : OpenSSL등의 소프트웨어를 사용하면 누구든지 인증 기관을 구축할 수 있어서 서버 증명서를 발행할 수 있다. 독자적으로 구축한 인증 기관을 자기 인증 기관이라 부르고, 쓸모없다는 뜻에서 나야나 증명서라고도 불린다. 

#### 2-4 안전한 통신을 하는 HTTPS

클라이언트가 메세지 송신(암호 스위트, SSL버전포함)하면 SSL 통신 시작 -> 
서버가 통신이 가능한 경우 메세지로 응답하고 서버의 암호 스위트 내용은 클라이언트에서 받은 암호 스위트에서 선택된 것 -> 서버가 공개키 인증서 포함한 Certificate 메세지 송신 -> 
서버가 메세지를 송신하여 최초의 SSL 네고시에이션 부분 끝남을 증명 -> 
네고시에이션 종료되면 클라이언트가 Client Key Exchange 메세지로 응답 (공개키 증명서에서 꺼낸 공개키로 암호화) -> 
클라이언트는 Change Cipher Spec 메세지를 전송해 이후의 통신은 암호키를 사용해서 진행한다는 것을 나타낸다 -> 
클라이언트는 Finished 메세지를 송신하고, 네고시에이션이 성공했는지는 서버가 이 메세지를 올바르게 복호화 하는지에 결정된다. -> 
서버에서도 마찬가지로  Change Cipher Spec 메세지와 Finished 메세지를 송신 -> 
메세지 교환이 완료되면 SSL에 의해서 접속은 확립된다. -> 
마지막에 클라이언트가 close_notify 메세지를 송신하면서 접속을 끊는다. 그 후에 TCP FIN 메세지를 보내 TCP 통신도 종료한다.

또한 애플리케이션 계층의 데이터를 송신할 때에는 MAC(Message Authentication Code)라고 부르는 메세지 다이제스트를 덧붙일 수 있다. MAC을 이용해서 변조를 감지할 수 있어서 완전성 보호를 실현할 수 있다. 