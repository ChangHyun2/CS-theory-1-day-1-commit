# 네트워크 어플리케이션의 원리

 네트워크 어플리케이션 개발은 다른 end-system에서 동작하고 네트워크를 통해 서로 통신하는 프로그램을 작성하는 것이다. 중요한 점은 계층 구분으로 애플리케이션 개발자가 라우터나 링크 계층 스위치 같은 **네트워크 코어 장비에서 실행되는 SW를 작성할 필요는 없다**는 것이다.

 end-system에만 어플리케이션 SW가 존재한다는 기본 설계는 인터넷 어플리케이션의 광대하고 빠른 발전의 원동력이 됐다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/52cf2524-5822-413c-846d-acb322566d1c/Untitled.png](./application-layer/0.png)

## 네트워크 애플리케이션 구조

  애플리케이션 개발자 관점에서 네트워크 구조는 고정되어 있고 애플리케이션에 특정 서비스 집합을 제공한다.

 **애플리케이션 구조(application architecture)**는 애플리케이션이 다양한 end system에서 어떻게 조직되어야 하는지를 지시한다. 이는 애플리케이션 개발자가 설계하는 것이다. 대표적인 구조로 Client-Server 구조, P2P 구조가 있다.

### 클라이언트-서버 구조 (client-server architecture)

 항상 켜져 있는 호스트를 서버(server)라 부르는데, 이 서비스는 클라이언트(client)라는 다른 호스트들의 요청을 받는다. 클라이언트는 항상 켜져 있을 필요는 없다. 이 구조의 특징은 다음과 같다.

- 클라이언트는 서버로 서비스를 요청하고 서버는 요청된 객체를 응답한다.
- 클라이언트는 서로 직접적으로 통신하지 않는다.
- 서버가 고정 IP 주소를 갖는다.
- 클라이언트-서버 구조의 예로는 웹, 파일 전송, 원격 로그인, 이메일 서비스 등이 있다.
- 하나의 서버 호스트가 모든 클라이언트의 요청을 응답하는 것이 불가능한 경우가 있다.
→ 많은 수의 호스트를 갖춘 **데이터 센터**가 가상의 서버를 생성하는 기술을 사용한다.
- 서비스 제공자들은 데이터 센터로부터 데이터를 보내기 위해 상호연결과 대역폭에 대한 비용을 지불하기도 한다.

### P2P 구조 (peer-to-peer architecture)

 항상 켜져 있는 기반구조 서버에 의존하지 않거나 최소로 의존한다. 대신 어플리케이션은 피어(peer)라는 간헐적으로 연결된 호스트 쌍이 **서로 직접 통신**하도록 한다. 피어는 서비스 제공자가 소유하지 않고 사용자들이 제어하는 데스크톱이나 랩톱이다.

- 예시로는 파일 공유 [BitTorrent], 피어-지원 다운로드 가속기[Xunlei], 인터넷 전화 및 비디오 컨퍼런스 [스카이프] 등이 있다.
- **자가 확장성**(self-scalability)를 갖는다. 예를 들어, 파일 공유 app에서는 비록 각 피어들이 파일을 요구함으로써 작업 부하를 만들어 내지만 각 피어들은 또한 파일을 다른 피어들에게 분배함으로써 **그 시스템에 서비스 능력을 추가**한다.
- 상당한 서버 기반구조와 서버 대역폭을 요구하지 않기 때문에 **비용 효율적**이다.
- 고도의 분산 구조 특성으로 인해 보안, 성능, 신뢰성 등에 단점이 있다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/96a9c21f-f9a3-46a0-a741-7439815b9f6f/Untitled.png](./application-layer/1.png)

---

## 프로세스 간 통신

 네트워크에서 서로 통신하는 것은 프로세스(process)이다. 즉, 서로 다른 호스트의 각 프로세스가 네트워크를 통한 **메시지 교환**으로 서로 통신한다. 송신 프로세스는 메시지를 만들어 네트워크로 보내면 네트워크는 그 메시지를 수신 프로세스로 잘 전달하는 의무를 갖는다.

### 클라이언트와 서버 프로세스

  네트워크 애플리케이션은 네트워크에서 서로 메시지를 보내는 두 프로세스로 구성되는데 두 프로세스를 클라이언트와 서버로 구분할 수 있다.

 클라이언트와 서버 프로세스를 다음과 같이 정의할 수 있다.

**두 프로세스 간의 통신 세선에서 통신을 초기화(다른 프로세스와 세션을 시작하려고 접속을 초기화)하는 프로세스를 클라이언트라 하고, 세션을 시작하기 위해 접속을 기다리는 프로세스를 서버라고 한다.**

- 웹 애플리케이션의 웹 브라우저 프로세스(client)는 웹 서버 프로세스(server)와 메시지를 교환한다.
- P2P 파일 공유 시스템의 한 피어 프로세스(client process)는 다른 피어의 프로세스(server process)로 파일을 전송한다.

### 소켓 (socket)

 하나의 프로세스로부터 다른 프로세스로 보내는 메시지는 네트워크를 통해 움직인다. 이때 프로세스는 **소켓(socket)**을 통해 네트워크로 메시지를 보내고 받는다.

 

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/624210d8-75d1-4c8d-8825-bb625777e5d5/Untitled.png](./application-layer/2.png)

 소켓은 네트워크 애플리케이션이 인터넷에 만든 프로그래밍 인터페이스이므로, **애플리케이션과 네트워크 사이의 API (Application Programming Interface)**라고도 한다. 애플리케이션 개발자는 소켓의 애플리케이션 계층에 대한 모든 통제권을 갖지만 소켓의 트랜스포트 계층에 대한 통제권을 거의 갖지 못한다.

 트랜스포트 계층에 대한 애플리케이션 개발자의 통제는 다음 뿐이다.

1. 트랜스포트 프로토콜의 선택
2. 최대 버퍼와 최대 세그먼트 크기와 같은 약간의 트랜스포트 계층 매개변수의 설정

### 프로세스 주소 배정

 수신 프로세스를 식별하기 위해, 두 가지 정보가 명시될 필요가 있다.

1. 호스트의 주소
2. 그 목적지 호스트 내의 수신 프로세스를 명시하는 식별자

 인터넷에서 호스트는 **IP주소**로 식별된다. 또한 호스트 내의 수신 프로세스를 목적지 **포트 번호(port)**로 식별할 수 있다.

 인기 있는 응용은 특정한 포트 번호가 할당된다. 예를 들어, 웹 서버는 80번으로, 메일 서버는 25번으로 식별된다. ([참조](http://www.iana.org))

---

## 애플리케이션이 이용 가능한 트랜스포트 서비스

 인터넷을 포함해서 많은 네트워크들은 하나 이상의 트랜스포트 프로토콜을 제공한다. 애플리케이션 개발자들은 사용 가능한 트랜스포트 프로토콜 중에서 하나를 선택해야 한다.

 개발하려는 애플리케이션이 요구하는 서비스에 맞춰 트랜스포트 프로토콜을 결정할 수 있는데 프로토콜이 제공하는 서비스들은 크게 네 가지로 나눌 수 있다.

### 신뢰적 데이터 전송

 패킷은 컴퓨터 네트워크 내에서 손실될 수 있다. (라우터 버퍼에서 오버플로우, 패킷의 비트가 잘못되어 호스트/라우터에 의해 버려짐)

 이메일, 파일 전송, 원격 호스트 접속, 웹 문서 전송 및 재무 애플리케이션과 같은 경우 데이터 손실은 위험한 결과를 가져온다. 따라서 이들 애플리케이션을 지원하기 위해 한 애플리케이션이 보낸 데이터가 올바르고 완전히 다른 애플리케이션에 전달되도록 보장하기 위해 조치를 취할 수 있다.

 이렇게 프로토콜이 보장된 데이터 전송 서비스를 제공하는 것을 **신뢰적 데이터 전송**을 제공한다고 한다.

 반면, 어느 정도의 데이터 손실을 참아낼 수 있는 실시간 오디오/비디오 혹은 저장 오디오/비디오와 같은 멀티미디어 애플리케이션은 **손실 허용 애플리케이션(loss-tolerant application)**이라고 한다. 이들의 손실 데이터는 플레이되는 오디오/비디오 품질에 약간의 영향을 미칠 수 있다.

### 처리량

 네트워크 경로를 따라 두 프로세스 간의 통신 세션에서 **송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율**을 처리량(throuput)이라고 한다.

 다른 세션들이 네트워크 경로를 따라 대역폭을 공유하고, 이 세션들이 생겼다 없어졌다 하기 때문에 가용한 처리율은 시간에 따라 변동한다. 하지만 트랜스포트 프로토콜은 어느 명시된 속도에서 보장된 가용 처리율을 제공한다.

 예를 들어, 인터넷 전화 애플리케이션이 32kbps로 음성을 인코드하면, 이 애플리케이션은 이 속도로 데이터를 네트워크로 보내야 하고 수신 애플리케이션으로 전달되어야 한다. 만약 트랜스포트 프로토콜이 이 처리율을 제공할 수 없다면, 애플리케이션은 낮은 속도로 인코드하거나 포기해야 한다.

- **대역폭 민감 애플리케이션(bandwidth-sensitive application):** 처리율 요구 사항을 갖는 애플리케이션. ex) 멀티미디어 애플리케이션
- **탄력적 애플리케이션(elastic appliction)**: 가용한 처리율을 많으면 많은 대로 적으면 적은 대로 이용. ex) 이메일, 파일 전송, 웹 전송 애플리케이션

### 시간

 **상호 작용 실시간 애플리케이션**에서는 애플리케이션이 효과적으로 동작하기 위해 데이터 전송에 엄격한 시간제한 조건을 요구한다. 예를 들어, 인터넷 폰에서의 긴 지연 시간은 대화하는데 부자연스러운 정지 기간을 야기한다.

 **비실시간 애플리케이션**의 경우 낮은 지연이 항상 높은 지연보다 좋지만 end system간 지연에 엄격한 제약을 받지는 않는다.

### 보안

 하나 이상의 보안 서비스를 제공할 수 있다. 두 프로세스 사이의 데이터가 어느 정도 관찰된다 하더라도 **비밀성**을 보장한다.

 예를 들어, 송신 호스트에서 트랜스포트 프로토콜은 송신 프로세스가 전송하는 모든 데이터를 암호화할 수 있고 수신 호스트에서 그 프로토콜은 데이터를 수신 프로세스로 전달하기 전에 해독할 수 있다.

 트랜스포트 프로토콜은 비밀성 이외에도 **데이터 무결성**과 **종단 인증** 등의 서비스를 제공할 수 있다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0cb987d4-0a33-4682-bb42-11c629396363/Untitled.png](./application-layer/3.png)

---

## 트랜스포트 프로콜이 제공하는 서비스

 일반적으로 2개의 전송 프로콜이 존재한다. UDP (User Datagram Protocol)과 TCP(Transmission Control Protocol)를 제공한다.

 개발자들이 새로운 인터넷 애플리케이션을 만들 때 첫 번째 결정해야 하는 것 중 하나가 UDP 또는 TCP 중 어느 것을 사용할지이다.

### TCP 서비스

- **연결지향형 서비스**

     애플리케이션 계층 메시지를 전송하기 전에 TCP는 클라이언트와 서버가 서로 전송 제어 정보를 교환하도록 한다. 이 **핸드셰이킹 과정**이 클라이언트와 서버에 패킷이 곧 도달할 것이니 준비하라고 알려 주는 역할을 한다. 

     이 셰이킹 단계를 지나면, TCP 연결이 두 프로세스의 소켓 사이에 존재한다고 할 수 있고 두 프로세스가 서로 동시에 메시지를 보낼 수 있다 (full-duplex connection). 애플리케이션이 메시지 전송을 마치면 연결을 끊어야 한다. 

- **신뢰적인 데이터 전송 서비스**

     통신 프로세스는 모든 데이터를 오류 없이 올바른 순서로 전달하기 위해 TCP에 의존한다. TCP는 애플리케이션의 한쪽이 바이트 스트림을 소켓으로 전달하면 그 바이트 스트림을 손실하거나 중복되지 않게 수신 소켓으로 전달한다. → congestion control, flow control

### UDP 서비스

 최소의 서비스 모델을 가진 간단한 전송 프로토콜이다.

- **비연결형 서비스**

     두 프로세스가 통신 하기 전에 핸드셰이킹을 하지 않는다. 

- **Best-effort 서비스 (비신뢰적인 데이터 전송 서비스)**

     하나의 프로세스가 UDP 소켓으로 메시지를 보내면, 그 메시지가 수신 소켓에 도착하는 것을 보장하지 않는다. 또한 수신 소켓에 도착하는 메시지들의 순서가 뒤바뀔 수 있다.

     UDP는 혼잡제어 (Congestion control) 방식을 포함하지 않기 때문에 송신 측이 원하는 속도로 네트워크 계층으로 보낼 수 있다. 하지만 실제 종단간 처리율은 중간 링크들의 제한된 대역폭 혹은 혼잡으로 인해 이 속도보다 작아질 수 있다.

### 인터넷 전송 프로토콜이 제공하지 않는 서비스

  TCP와 UDP에 대해서 **처리율** 혹은 **시간 보장**에 대한 이야기는 빠졌다. 이는 분명히 인터넷 전송 프로토콜이 제공하지 않는 서비스이다.

 하지만 인터넷 전화와 같은 시간 민감 애플리케이션이 오늘날의 인터넷에서 수행될 수 없다는 것을 의미하지는 않는다. 그 이유는 이러한 보장이 없는 경우에도 가능한 잘 대처할 수 있도록 TCP나 UDP가 설계되었기 때문이다.

 즉, 오늘날의 인터넷은 때로 시간 민감 애플리케이션에게 만족스런 서비스를 제공할 수는 있으나 시간 혹은 대역폭 보장을 제공할 수는 없다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b4070d0c-96a7-4c73-871c-163e5d2ab1a7/Untitled.png](./application-layer/4.png)

 인터넷 전화 응용 개발자들은 보통 UDP를 채택하는데 많은 방화벽(firewall)들이 대부분 형태의 UDP 트래픽을 차단하도록 설정되어 있기 때문에, UDP 통신이 실패할 경우를 대비하여 TCP를 사용하도록 설계되어 있다.

---

## 애플리케이션 계층 프로토콜

 애플리케이션 계층 프로토콜은 다른 end system에서 실행되는 애플리케이션의 프로세스가 서로 메시지를 보내는 방법을 정의한다. 

- 교환 메시지 타입 (예: 요청 메시지와 응답 메시지)
- 여러 메시지 타입의 문법 (예: 메시지 내부의 필드와 필드 간의 구별 방법)
- 필드의 의미, 즉 필드에 있는 정보의 의미
- 언제, 어떻게 프로세스가 메시지를 전송하고 메시지에 응답하는지 결정하는 규칙

 네트워크 애플리케이션과 애플리케이션 계층 프로토콜을 구별하는 것은 중요하다. 애플리케이션 계층 프로토콜은 네트워크 애플리케이션의 한 요소일 뿐이다.

- Web Application은 HTML, 웹 브라우저, 웹 서버, 그리고 HTTP를 포함하는 여러 요소들로 구성된다.
- 인터넷 E-mail Application은 사용자 메일박스를 갖고 있는 메일 서버, 메일 클라이언트, SMTP(Simple Mail Transfer Protocol) 등으로 구성된다.

# [웹과 HTTP](./HTTP/overview.md)

 웹이 여러 데이터 네트워크 중 유일한 데이터 네트워크로 격상될 수 있었던 웹의 특징은 다음과 같다.

1. 온-디맨드 방식으로 동작: 사용자가 원할 때, 원하는 것을 수신할 수 있다.
2. 모든 사람이 매우 낮은 비용으로 발행자가 될 수 있다.
3. 웹과 관련된 프로토콜들은 대부분의 모바일 인터넷 애플리케이션을 위한 플랫폼을 제공한다.

## HTTP 개요

 웹은 애플리케이션 계층 프로토콜로 **HTTP (HyperText Transfer Protocol)**을 채택했다. HTTP는 클라이언트 프로그램과 서버 프로그램, 두 가지 프로그램으로 구현되는데 서로 다른 end-system에서 수행되는 각 프로그램이 서로 HTTP 메시지를 교환하여 통신한다.

 HTTP는 메시지의 구조 및 클라이언트와 서버가 메시지를어떻게 교환하는지에 대해 정의한다.

 웹 페이지는 객체들로 구성된다. **객체(object)**는 단순히 단일 URL로 지정할 수 있는 하나의 파일이다. 이 파일은 HTML 파일이 될 수도 있고, JPEG 이미지, GIF 이미지, 자바 애플릿, 오디오 클립 등이 될 수 있다. 대부분의 웹 페이지는 기본 HTML 파일과 여러 참조 객체로 구성된다.

### URL 구조

 예시 URL:  http://www.someSchool.edu/someDepartment/picture.gif

 URL은 2개의 요소, 객체를 갖고 있는 서버의 호스트 네임과 객체의 경로 이름을 갖고 있다. http는 프로토콜을 나타내고, www.someSchool.edu는 호스트 네임이고, /someDepartment/picture.gif는 경로 이름이다.

 **웹 브라우저**는 HTTP의 클라이언트 측을 구현하고 서버 측을 구현한 **웹 서버(Web server)**는 URL로 각각을 지정할 수 있는 웹 객체를 갖고 있다. 인기 있는 웹 서버로는 아파치, 마이크로소프트 인터넷 인포메이션 서버(IIS) 등이 있다.

 사용자가 웹 페이지를 요청할 때, 브라우저는 페이지 내부의 객체에 대한 HTTP 요청 메시지를 서버에게 보낸다. 서버는 요청을 수신하고 객체를 포함하는 HTTP 응답 메시지로 응답한다.

### HTTP 프로토콜의 전송 프로토콜: TCP

 TCP는 HTTP에게 신뢰적인 데이터 전송 서비스를 제공한다. 따라서 HTTP는 데이터의 손실 또는 TCP가 어떻게 손실 데이터를 복구하고 네트워크 내부에서 데이터를 올바른 순서로 배열하는지 걱정할 필요가 없다. 

 서버가 클라이언트에게 요청 파일을 보낼 때, 서버는 클라이언트에 관한 어떠한 상태 정보도 저장하지 않는다.  → **비상태 프로토콜(stateless protocol)**

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cd09f27e-0b0d-4893-8c60-bdbcbb3eef52/Untitled.png](./application-layer/5.png)

 

---

## 비지속 연결과 지속 연결

 애플리케이션 개발자는 클라이언트-서버 상호작용이 TCP 상에서 발생할 때 결정을 내려야한다.

- **비지속 연결(non-persistent connection)**: 각 요구/응답이 분리된 TCP연결을 통해 보내져야 하는가?
- **지속 연결(persistent connection)**: 모든 요구와 해당하는 응답들이 같은 TCP 연결상으로 보내져야 하는가?

 기본 HTML 파일 1개와 10개의 JPEG 이미지로 구성된 페이지, 이 11개의 객체가 같은 서버에 있다고 가정하자. 해당 HTML 페이지의 URL은 다음과 같다.

http://www.someSchool.edu/someDepartment/home.index

### 비지속 연결 HTTP

 비지속 연결의 연결 수행 과정은 다음과 같다.

1. HTTP 클라이언트는 HTTP의 기본 포트 번호 80을 통해 [www.someSchool.edu](http://www.someSchool.edu) 서버로 TCP 연결을 시도한다. TCP 연결과 관련하여 클라잉너트와 서버에 각각 소켓이 있다.
2. HTTP 클라이언트는 설정된 소켓을 통해 서버로 HTTP 요청 메시지를 보낸다. 이 요청 메시지는 /someDepartment/home.index 경로 이름을 포함한다.
3. HTTP 서버는 연결된 소켓을 통해 요청 메시지를 받는다. 저장장치로부터 /someDepartment/home.index 객체를 추출하고 HTTP 응답 메시지에 그 객체를 캡슐화한다. 그리고 응답 메시지를 소켓을 통해 클라이언트로 보낸다.
4. **HTTP 서버는 TCP에게 TCP 연결을 끊으라고 한다.** ( 실제로는 TCP 클라이언트가 응답 메시지를 올바로 받을 때까지 유지된다. )
5. HTTP 클라이언트가 응답 메시지를 받으면, TCP 연결이 중단된다. 클라이언트는 메시지로부터 HTML 파일을 추출하고 조사하여 10개의 JPEG 객체에 대한 참조를 얻는다.
6. 이후에 참조되는 각 JPEG 객체에 대하여 1~4 단계를 반복한다.

 각 TCP 연결은 하나의 요청 메시지와 하나의 응답 메시지만 전송한다. 따라서 위 예제에서는 사용자가 웹 페이지를 요청할 때 11개의 TCP 연결이 만들어진다.

 HTML 파일을 얻은 후 10개의 TCP 연결에 대해 순차적으로 연결을 하는지 아니면 동시에 TCP 연결을 만들어 얻는지 정하지 않았다. 이는 웹 브라우저 사용자가 동시성 정도를 조절할 수 있다. 일반적으로 기본 모드에서 5~10개의 TCP 연결을 동시에 설정한다.

### 클라이언트가 요청~응답 메시지 수신까지의 시간 측정

 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 클라이언트로 되돌아오는 데 걸리는 시간을 RTT( round-trip time) 정의한다.

 RTT는 패킷 전파 지연(propagation delay), 중간 라우터와 스위치에서의 패킷 큐잉 지연 (queuing delay), 패킷 처리 지연(processing delay) 등을 포함한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5326181d-2aa4-487b-9f22-51678040ed6f/Untitled.png](./application-layer/6.png)

  사용자가 하이퍼링크를 클릭하면 일어나는 일을 나타낸다. 클릭은 브라우저가 브라우저와 웹 서버 사이에서 TCP연결을 시도하게 한다. 이는 "3-hand handshake"를 포함한다.

 three-hand handshake는 클라이언트가 작은 TCP 메시지를 서버로 보내고, 서버는 작은 메시지로 응답하고 마지막으로 클라이언트가 다시 서버에게 응답하는 방식으로 진행된다.

 이 과정의 첫 두 부분이 경과하면 한 RTT가 계산된다. 두 과정이 끝나고 클라이언트는 HTTP 요청 메시지를 TCP 연결로 보내면서 핸드셰이크의 세 번째 부분(응답)을 함께 보낸다. 이 요청 메시지가 성공적으로 서버에 도달하면 HTML 파일을 TCP 연결로 보낸다.

 이 HTTP 요청/응답은 또 하나의 RTT를 필요하므로 총응답 시간은 대략:

 [2*RTT + HTML 파일을 서버가 전송하는 데 걸리는 시간] 이다.

### 지속 연결 HTTP

 비지속 연결의 단점

1. 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 한다. → TCP 버퍼가 할당 → TCP 변수들이 클라이언트와 서버 양쪽에 유지 → 웹 서버에 심각한 부담
2. 각 객체는 2RTT를 필요로 한다.(TCP 연결 설정-1 RTT, 객체를 요청하고 받는 데 1 RTT)

 지속 연결에서 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지한다. 

 같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보내진다. 이들 객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어질 수 있다. [파이프라이닝]

 연결을 닫는 시기는 일정 기간(타임아웃 기간) 사용되지 않을 때이다. 서버가 연속된 요구를 수신할 때, 서버는 **객체를 연속해서 보낸다.**

 최근에, HTTP/2은 같은 연결에서 다중 요청과 응답이 가능하고 이 연결 내에서 HTTP 메시지 요청과 응답의 우선순위 기법이 가능하다.

---

## HTTP 메시지 포맷

 

### HTTP 요청 메시지

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f6ac146e-ee2f-4130-8f8a-bd7ddce6eb15/Untitled.png](./application-layer/7.png)

 

 특징은 다음과 같다.

1. 메시지가 일반 ASCII 텍스트로 쓰여 있어 사람들이 읽을 수 있다.
2. 메시지의 각 줄이 Carriage Return과 Line Feed로 구별된다.

 첫 줄은 **요청 라인(request line)**이라 부르고, 이후 줄 들은 **헤더 라인(header line)**이라 부른다.

 요청 라인은 3개의 필드, "방식(method) 필드", "URL 필드", "HTTP 버전 필드"를 갖는다. 대부분의 HTTP 메시지는 GET 방식을 사용하는데 GET 방식은 브라우저가 URL 필드로 식별되는 객체를 요청할 때 사용된다.

 헤더 라인에서

 Host: www.somescholl.edu는 객체가 존재하는 호스트를 명시한다. 이 호스트 헤더 라인이 제공하는 정보는 **웹 프록시 캐시**에서 필요로 한다.

 Connection: close 헤더 라인은 브라우저가 서버에게 지속 연결 사용을 원하지 않는다는 것을 알린다. 

 User-agent: 헤더 라인은 사용자 에이전트, 서버에게 요청을 하는 브라우저 타입을 명시하는데 서버가 같은 객체에 대한 다른 버전을 다른 타입의 사용자 에이전트에게 보낼 수 있다는 데에서 유용하다. Accept-language: 헤더 라인은 객체의 요청 언어를 명시한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2a301783-7a46-4d30-a0b5-764cd36defdb/Untitled.png](./application-layer/8.png)

  요청 라인과 헤더 라인의 모든 라인들은 CR과 LF로 줄이 구분된다. 또한, 헤더 라인 이후에 "개체 몸체(entity body)"가 있다. 보통 개체 몸체는 GET 방식에서 비어 있고 POST 방식에서 사용된다.

 HEAD 방식은 GET 방식과 유사하다. 서버가 HEAD 방식을 가진 요청을 받으면 HTTP 메시지로 응답하는데, 요청 객체는 보내지 않는다. 애플리케이션 개발자는 흔히 디버깅을 위해 HEAD 방식을 많이 사용한다.

 PUT 방식은 또한 웹 서버에 업로드할 객체를 필요로 하는 애플리케이션에 의해 사용된다. DELETE 방식은 사용자 또는 애플리케이션이 웹 서버에 있는 객체를 지우는 것을 허용한다.

### HTTP 응답 메시지

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9904feeb-188c-45ee-ab95-3a79c43d759b/Untitled.png](./application-layer/9.png)

 3개의 섹션으로 구분할 수 있다.

 초기 상태 라인, 6개의 헤더 라인, 개체 몸체로 이루어지는데 객체 몸체는 (data data data data ...)로 표현된 부분을 나타낸다.

 상태 라인은 프로토콜 "버전 필드", "상태 코드", "해당 상태 메시지"를 갖는다.

 헤더 라인을 살펴보면

1. [Connection: close]: 클라이언트에게 메시지를 보낸 후 TCP 연결을 닫는 데 사용한다.
2. Date: HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간을 나타낸다.
3. Server: 메시지가 아파치 웹 서버에 의해 만들어졌음을 나타낸다.
4. Last-Modified: 객체가 생성되거나 마지막으로 수정된 시간과 날짜를 나타낸다. 이 헤더는 로컬 클라이언트와 네트워크 캐시서버(proxy server)에서의 객체 캐싱에 중요하다.
5. Content-Length: 송신되는 객체의 바이트 수를 나타낸다.
6. Content-Type: 개체 몸체 내부의 객체가 HTML 텍스트인 것을 나타낸다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ce23f721-0c52-40c9-bf47-8772621f5b15/Untitled.png](./application-layer/10.png)

 대표적인 상태 코드와 연관 문장의 예로는,

- 200 OK: 요청이 성공되었고, 정보가 응답으로 보내졌다.
- 301 Moved Permanently: 요청 객체가 영원히 이동되었다. 새로운 URL은 응답 메시지의 Location: 헤더에 나와 있다. 클라이언트 소프트웨어는 자동으로 이 새로운 URL을 추출한다.
- 400 Bad Request: 서버가 요청을 이해할 수 없다는 일반 오류 코드이다.
- 404 Not Found: 요청 문서가 서버에 존재하지 않는다.
- 505 HTTP Version Not Supported: 요청 HTTP 프로토콜 버전을 서버가 지원하지 않는다.
---
## 쿠키

 HTTP 서버의 stateless 프로토콜 특성 **Pros & Cons**

**Pros**:

- 서버 설계가 간편
- 동시에 수천 개의 TCP 연결을 다룰 수 있는 고성능의 웹 서버 개발 가능

**Cons**:

- 사용자 접속을 제한
- 사용자에 따라 콘텐츠 제공 불가능

→ 사용자를 추적할 수 있는 쿠키(cookie) 사용

 

### 쿠키 기술의 요소

1. HTTP 응답 메시지 쿠키 헤더 라인
2. HTTP 요청 메시지 쿠키 헤더 라인
3. 사용자의 브라우저에 사용자 종단 시스템과 관리를 지속시키는 쿠키 파일
4. 웹 사이트의 백엔(back-end) 데이터베이스

### 웹 사이트 접속 예시

1. 아마존 웹 서버에 요청이 들어올 때 그 요청에 대해 유일한 식별번호를 만든다.
2. 식별번호로 인덱스되는 백엔드 데이터베이스 안에 엔트리를 만든다.
3. 요청에 응답할 때 HTTP 응답에 식별번호를 담고 있는 Set-cookie 헤더를 포함시킨다.
4. 요청을 받는 브라우저는 자신이 관리하는 특정한 쿠키 파일에 라인을 덧붙인다.
라인은 서버의 호스트 네임과 Set-cookie: 헤더와 식별번호를 포함한다.
5. 계속해서 웹 사이트 내에서 활동함에 따라 쿠키 파일을 참조하고 이 사이트에 대한 식별번호를 발췌하고, HTTP 요청에 식별번호를 포함하는 쿠키 헤더 파일을 넣는다.
6. 아마존 서버로의 모든 HTTP 요청은 "Cookie: 자신의 식별번호"의 헤더 라인을 포함한다.
7. 일주일 후에 다시 접속하여 쿠키를 헤더 라인에 넣어 요청하면 과거에 아마존에서 방문한 웹 페이지에 기초하여 제품을 추천한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a80c8ce4-1e22-48c5-a473-1b92e2425376/Untitled.png](./application-layer/11.png)

 

이와 같이 쿠키는 비상태 HTTP 위에서 사용자 세션 계층을 생성하는 데 이용될 수 있다. 쿠키는 위 예시처럼 사용자를 위해 인터넷 쇼핑 경험을 간소화하지만, 사용자 사생활에 대한 침해로 보일 수 있음에 따라 큰 논쟁거리다. → 쿠키 센트럴[Cookie Central]

---

## 웹 캐싱

 웹 캐싱[Web cache; 프록시 서비]는 origin web server를 대신하여 HTTP 요구를 충족시키는 네트워크 개체이다. 웹 캐시는 자체의 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장/보존한다.

### 웹 캐싱 시나리오 (http://www.someschool.edu/campus.gif 요청)

1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다.
2. 웹 캐시는 객체의 사본이 자기에게 저장되어 있는지 확인한다. 만일 저장되어 있다면 웹 캐시는 클라이언트 브라우저로 HTTP 응답 메시지와 함께 객체를 전송한다.
3. 만약 웹 캐시가 객체를 가지고 있지 않다면, 웹 캐시는 origin 서버인 www/someschool.edu로 TCP 연결을 설정한다. 이후 웹 캐시는 캐시와 서버 간의 TCP 연결로 객체에 대한 HTTP 요청을 보낸다. 요청을 받은 후에 기점 서버는 웹 캐시로 HTTP 응답 메시지와 함께 객체를 보낸다.
4. 웹 캐시가 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메시지와 함께 객체의 사본을 보낸다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1e7a304f-b839-4438-acd7-008e1d254a84/Untitled.png](./application-layer/12.png)

### 웹 캐싱의 이점

 일반적으로 웹 캐시는 ISP가 구입하고 설치한다. 보통은 다음과 같은 이유로 사용된다.

1. 웹 캐시는 클라이언트의 요구에 대한 응답 시간을 줄일 수 있다.
특히, 대역폭의 크기가 클라이언트~캐시 >>>> 클라이언트~오리지널 서버 일 때 더 효과적이다. 보통 클라이언트와 캐시 사이에는높은 속도의 연결이 설정되어 있기 때문이다.
2. 웹 캐시는 한 기관에서 인터넷으로 접속하는 링크상의 웹 트래픽을 대폭으로 줄일 수 있다.

### 웹 캐싱 장점의 예시

 

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b2555135-ec67-498f-8a58-0c3ab0818b22/Untitled.png](./application-layer/13.png)

 기관 네트워크는 고속의 LAN이며 기관 네트워크에 있는 라우터와 인터넷의 라우터는 15Mbps 회선에 연결된다. 평균 객체의 크기가 1Mbit이고 기관 브라우저로부터 오리지널 서버에 대한 평균 요청비율이 초당 15 요청이라 하자.

 또한 HTTP 메시지 요청 자체는 무시할 만큼 작아서 네트워크나 접속 회선에 어떤 트래픽도 발생시키지 않는다고 가정한다. 접속회선의 인터넷 부분 라우터가 HTTP 요청을 전달하고 응답을 받을 때까지 평균 소요시간은 2초라 가정한다. (이러한 지연을 "인터넷 지연"이라 한다.)

 총 응답 시간은 LAN 지연과 접속 지연(라우터 간의 지연), 인터넷 지연의 합과 같다.

LAN의 트래픽 강도는

 : (15요청/초) * (1 Mbit/요청)/(100 Mbps) = 0.15

접속 회선의 트래픽 강도는

 : (15요청/초) * (1 Mbit/요청)/(15Mbps) = 1

 일반적으로 LAN의 0.15 트래픽 강도는 많아야 수십 msec의 지연을 야기하므로 무시할 수 있지만 접속 회선의 경우 1에 가까워지면 지연이 매우 커지고 한없이 증가한다. → 평균 응답 시간이 몇 분이 걸린다.

 해결 방법은 두 가지 방법을 생각할 수 있다.

1. 접속률을 15Mbps에서 100Mbps로 늘린다. → 비용이 많이 든다.
2. 기관 네트워크에 웹 캐시를 설치한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f9395df4-8327-4f51-9f7f-37c700fd21a7/Untitled.png](./application-layer/14.png)

 캐시 적중률은 일반적으로 0.2~0.7이므로 대략 0.4라고 한다면 요청의 40%는 캐시에 의해 즉시(10 msec 이내) 만족된다.

 여전히 60%의 요청은 오리지널 서버에 의해 만족되어야 하지만 요청된 객체의 60%만 접속 회선을 통과하므로 트래픽 강도는 1.0에서 0.6으로 감소된다. 일반적으로 0.8 미만의 트래픽 강도는 15 Mbps 회선에서 수십 msec 정도로 작은 지연에 속한다.

 따라서 캐시에 의해 단축된 평균 지연 시간은

 0.4 * (0.01 sec) + 0.6 * (2.01 sec)로 대략 1.2초가 조금 넘는다. 이 지연 시간은 회선의 접속률을 늘리는 것보다 낮은 응답 시간이고 회선 증설보다 비용도 저렴하다.

### 콘텐츠 전송 네트워크 (CDN, Content Distribution Network)

 CDN 회사는 인터넷 전역을 통해 많은 지역적으로 분산된 캐시를 설치하고 있으며, 이를 통해 많은 트래픽을 지역화하고 있다.

 그 종류로는 다음이 있다.

- **공유 CDN** : 아카마이(Akamai)와 라임라이트(LimeLight)
- **전용 CDN:** 구글과 마이크로소프트

### 조건부 GET

 웹 캐싱의 문제점으로는 캐시 내부에 있는 객체의 복사본이 최근의 것이 아닐 수 있다. 즉, 복사본이 클라이언트에 캐시된 이후에 웹 서버에 있는 객체가 갱신되었을 수도 있다.

 HTTP는 모든 객체들이 최신의 것임을 확인하면서 캐싱하는 방식을 갖고 있는데 이를 **조건부 GET (conditional GET)**이라고 한다.

 조건부 GET은 요청 메시지가 (1) GET 방식을 사용하고, (2) If-Modified-Since: 헤더 라인을 포함하고 있을 때이다.

### 조건부 GET 예시

1. 브라우저의 요청을 대신해 프록시 캐시는 요청 메시지를 웹 서버로 보낸다.

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f11f7939-1dd6-43c2-9f80-5dc3d9166f8a/Untitled.png](./application-layer/15.png)

2. 웹 서버는 캐시에게 객체를 가진 응답 메시지를 보낸다.

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5649a3d3-9b95-4349-a708-9796b9248c43/Untitled.png](./application-layer/16.png)

     캐시는 요청하는 브라우저에게 객체를 보내 주고 자신에게도 객체를 저장한다. 이때, 마지막으로 수정된 날짜를 함께 저장한다. (Last-Modified)

3. 일주일 후에 다른 브라우저가 같은 객체를 캐시에게 요청한다.

     이 객체는 지난주에 웹 서버에서 수정되었으므로 브라우저는 조건부 GET으로 갱신 조사를 수행한다. 브라우저는 특히 다음과 같은 헤더를 보낸다.

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1960d092-f47e-4fce-89ba-39b3bc915010/Untitled.png](./application-layer/17.png)

     만약 명시된 날짜 이후 수정된 경우에만 그 객체를 보낼 것을 말한다. 만약 수정되지 않았다면,

4. 웹 서버는 클라이언트에게 다음과 같은 메시지를 보낸다.

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/73663f7c-1e73-436d-a7e0-46616a661d50/Untitled.png](./application-layer/18.png)

     응답 메시지에는 요청된 객체를 포함하지 않는다. 요청 객체를 포함하는 것은 대역폭을 낭비하는 것이고, 그 개체가 크다면 사용자가 느끼는 응답 시간이 증가된다.

     마지막 응답 메시지는 304 Not Modified 상태 라인을 갖고 있으며, 이는 클라이언트에게 요청 객체의 캐시된 복사본을 사용하라는 것을 의미한다.