# 비디오 스트리밍과 CDN

- 녹화된 비디오를 스트리밍하면 북미 지역 주거용 ISP의 트래픽의 대부분을 차지
- 예) 넷플릭스와 유튜브 서비스는 2015년도에 주거용 ISP 트래픽이 각각 37%와 16% 사용
- 캐시와 같은 기능을 한느 응용프로그램 수준 프로토콜과 서버를 사용하여 구현

## 인터넷 비디오

- 스트리밍 비디오 어플리케이션에서는 녹화된 비디오가 서버에 저장되어 사용자가 비디오 시청을 **온디맨드(on-demand)**로 요청
- 비디오는 이미지의 연속 (초당 24개 또는 30개의 이미지) → 일정한 속도
- 압축되지 않은 디지털 인코딩된 이미지는 픽셀 단위, 각 픽셀은 여러 비트들로 인코딩
- 하지만 비디오는 **압축될 수 있음**
- 비디오 품질과 비트 전송률은 trade-off
- 오늘날의 상용 압축 알고리즘으로 원하는 모든 비트 전송률로 비디오 압축 가능
- 비디오의 가장 두드러진 특성: 높은 비트 전송률
- 압축된 인터넷 비디오는 고화질 동영상 스트리밍을 위해 100 kbps에서 300kbps 이상으로 구성
- 특히, 4K 스트리밍은 10 Mbps 이상의 비트전송율 → 트래픽 및 스토리지 용량이 엄청나게 필요
- 가장 중요한 성능 척도는 평균 종단간(end-to-end) 처리량
- 연속재생을 위해서 네트워크는 **압축된 비디오의 전송률 이상의 평균 처리량**을 제공해야함
- 압축을 통해 여러 버전의 품질을 만들 수 있음
- 여러 버전의 동영상 중에 사용 가능한 대역폭을 선택하여 보고 싶은 버전 결정 (예, 300 kbps, 1 Mbps, 3 Mbps 등)

---

## HTTP 스트리밍 및 대쉬(DASH)

- HTTP 스트리밍에서 비디오는 HTTP 서버 내의 특정 URL을 갖는 일반적인 파일로 저장
- 비디오 시청을 원하면 TCP 연결을 만들고 해당 URL에 대한 HTTP GET 요청
- 클라이언트 측은 응답 비디오 파일(바이트)을 **애플리케이션 버퍼**에 저장
- 버퍼의 바이트 수가 미리 정해진 임계값을 초과하면 클라이언트 애플리케이션이 재생 시작
- 특히 스트리밍 비디오 애플리케이션은 클라이언트의 버퍼에서 주기적으로 **비디오 프레임**을 가져와 프레임을 압축해제한 다음 사용자 화면에 표시
- →비디오의 후반 부분에 해당하는 프레임을 수신하고 버퍼링할 때 비디오를 표시

### HTTP 기반 스트리밍의 문제점

- 모든 클라이언트들이 그들 사이의 가용 대역폭의 차이에도 불구하고 **똑같이 인코딩된 비디오**를 전송받음
- 이 차이는 서로 다른 클라이언트 뿐만 아니라 동일한 클라이언트에서도 시간에 따른 차이 발생

### 해결책: DASH (Dynamic Adaptive Streaming over HTTP)

- 비디오가 여러 개의 서로 다른 버전으로 인코딩되며, 각 버전은 서로 다른 비트율과 품질 수준
- 클라이언트는 **동적으로** 서로 다른 버전의 비디오를 몇 초 분량의 길이를 가지는 **비디오 조각 단위(chunk)**로 요청
- 가용 대역폭이 충분할 때 → 높은 비트율의 비디오 버전 요청, 적을 때 → 낮은 비트율 버전 요청
- 클라이언트는 HTTP GET 요청으로 **다른 버전의 비디오 조각을 매번 선택**
    - 서로 다른 인터넷 접속회선을 가진 클라이언트들에게 선택할 수 있도록 함
    - 세션 유지 중에 **시간에 따라 변화하는 종단간 가용 대역폭에 적응**할 수 있도록 허용 → 이동 중에 접속하는 기지국의 상황에 따라 자주 변화
- 각 비디오 버전은 HTTP 서버에 서로 다른 URL을 가지고 저장
- 비트율에 따른 각 버전의 URL을 제공하는 **매니패스트(manifest) 파일**
    - 매니패스트 파일 요청 → 서버에서 제공되는 다양한 버전에 대해 알게됨
    - 매번 원하는 버전의 chunk를 선택해서 HTTP GET 메시지에 **URL과 byte-range**를 지정하여 요청
    - chunk를 다운로드하는 동안 수신 대역폭 측정
    - 비트율 결정 알고리즘으로 통해 다음에 선택할 chunk 버전 결정
- DASH는 클라이언트가 **서로 다른 품질 수준을 자유롭게 변화**시킬 수 있도록 한다.

---

## 콘텐츠 분배 네트워크(CDN)

### 단일한 거대 데이터 센터 아키텍처의 문제점

1. 클라이언트가 데이터 센터로부터 지역적으로 먼 지점에 있는 경우, 클라이언트로의 패킷 경로에 많은 다양한 통신 링크와 ISP가 존재

    이들 링크 중 하나라도 비디오 소비율보다 낮은 전송용량을 갖는다면 종단간 처리율이 낮아짐

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bc75f6d4-144c-4a6e-b1ae-d716fa73e2a9/Untitled.png](./CDN/0.png)

2. 인기 있는 비디오는 같은 통신 링크를 통해 여러 번 반복적으로 전송
    - 네트워크 대역폭 낭비
    - 회선을 제공하는 ISP 들에게 동일한 바이트를 전송하는 것에 대한 중복 비용 지불
3. 한 번의 장애로 전체 서비스가 중단될 수 있음

### 콘텐츠 분배 네트워크

- 다수의 지점에 분산된 서버들을 운영
- 비디오 및 다른 형태의 웹 콘텐츠 데이터의 복사본을 분산 서버에 저장
- 사용자는 최선의 서비스와 UX를 제공할 수 있는 지점의 CDN 서버로 연결
    - 사설 CDN: 콘텐츠 제공자가 소유. ex) 구글의 CDN (유튜브)
    - 제3자가 운영하는 CDN ex) Akamai, Limelight, Level-3
- 서버의 위치에 따른 두 가지 철학
    - **Enter Deep**
        - Akamai에 의해 주창
        - 서버 클러스터를 **세계 곳곳의 접속 네트워크에 구축** → ISP의 접속 네트워크로 깊숙이 들어감
        - 목적: 서버를 최대한 사용자 가까이에 위치시켜 사용자와 CDN 서버 사이의 링크 및 라우터 수를 줄임 → 지연시간 및 처리율을 개선
        - 문제점: 고도로 분산된 설계로 **서버 클러스터 유지 관리 비용**이 커짐
    - **Bring Home**
        - Limelight와 다른 회사들에 의해 적용
        - 보다 적은 수의 핵심 지점에 큰 규모의 서버 클러스터 구축 → ISP를 Home으로 가져옴
        - 접속 ISP에 연결하는 대신, 클러스터를 **인터넷 교환지점 (IXPs)**에 배치
        - 관리 비용이 줄어들지만 사용자가 느끼는 지연시간과 처리율이 나빠짐
- CDN은 클러스터에 대해 **Pull 방식** 사용
    - 사용자가 지역 클러스터에 없는 비디오 요청
    - 해당 비디오를 중앙 서버나 다른 클러스터로부터 전송받아 사용자에게 서비스하는 동시에 복사본을 저장
    - 저장 공간이 가득 차면 자주 사용되지 않는 비디오 데이터는 삭제