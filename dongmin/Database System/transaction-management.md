# 트랜잭션이란?  

- 하나의 논리적 작업 단위를 이루는 연산들의 집합
- 다양한 데이터 항목들을 액세스하고 갱신하는 프로그램 수행의 단위

 트랜잭션은 고급 데이터 조작 언어나 JDBC, ODBC 등을 사용하여 데이터베이스를 접근하는 프로그래밍 언어로 작성된 프로그램에 의해 시작된다. (begin transaction ~ end transaction) 

# 트랜잭션 성질

 데이터베이스 시스템은 다음과 같은 트랜잭션 성질들을 지원해야 한다.

- **원자성 (Atomicity)**: 트랜잭션의 모든 연산들이 정상적으로 수행 완료되거나 아니면 전혀 어떤 연산도 수행되지 않은 원래 상태가 되도록 해야 한다. (all-or-none)
- **일관성 (Consistency)**: 고립 상태(즉, 동시에 수행되는 트랜잭션이 없는 상태)에서의 트랜잭션 수행이 데이터베이스의 일관성을 보존해야 한다.
- **고립성 (Isolation)**: 여러 트랜잭션들이 동시에 수행되더라도, 모든 트랜잭션 $T_i$와  $T_j$의 쌍에 대해서 데이터베이스 시스템은  $T_i$에게  $T_i$가 시작되기 전에  $T_j$가 수행을 끝마쳤거나 아니면 $T_i$가 수행을 끝마친 후에 $T_j$가 수행을 시작하는 것과 같이 되도록 보장해야 한다. 따라서 각 트랜잭션은 시스템에서 다른 트랜잭션이 동시에 수행하고 있는지를 알지 못한다.
- **지속성 (Durability)**: 트랜잭션이 성공적으로 수행 완료되고 나면, 트랜잭션에 의해 데이터베이스에 변경된 내용은 시스템에 오류가 발생한다 하더라도 지속돼야 한다.

 이 성질들을 줄여 ACID 성질이라고 한다. 

그런데 고립성 성질을 보장하는 것은 시스템의 성능을 저하시키기 때문에 몇 애플맅케이션은 고립성 조건을 완화하기도 한다.

# 트랜잭션 상태

 트랜잭션은 다음과 같은 상태 중에 하나를 가져야 한다.

![transaction](https://t1.daumcdn.net/cfile/tistory/99890D335C15F65D29)

- **동작 (active)**: 초기 상태로, 트랜잭션이 실행 중이면 동작 상태에 있다고 말할 수 있다.
- **부분 커밋 (partially commit)**: 마지막 명령문이 실행된 후의 상태를 말한다.
- **실패 (failed)**: 정상적인 실행이 더 이상 진행될 수 없을 때 가지는 상태이다.
- **중단 (aborted)**: 트랜잭션이 롤백되고 데이터베이스가 트랜잭션 시작 전 상태로 환원되고 난 후의 상태이다.
- **커밋 (committed)**: 트랜잭션이 성공적으로 완료된 후의 상태이다.

 트랜잭션이 항상 성공적으로 동작하지는 않기 때문에 실패한다면 중단되어야 한다. 이때의 상태를 중단(aborted)되었다고 하는데 **원자성**을 보장해야 하기 때문에,
중단되 트랜잭션이 중단되기 전까지 데이터베이스에 행한 갱신내용은 모두 이전 상태로 복구된다. 이렇게 중단된 트랜잭션에 의해 수행된 갱신내용이 무효화될 경우 트랜잭션이 **롤백(rollback)**되었다고 한다. 이 복구 기법으로 주로 **로그**를 유지하는 방법을 사용한다.

 성공적으로 실행을 완료한 트랜잭션을 **커밋(commit)**되었다고 한다. 갱신을 수행한 트랜잭션이 커밋되면 데이터베이스는 그 트랜잭션에 의해 새로운 일관된 상태로 변경된 것이다. 트랜잭션이 커밋되면 그 트랜잭션을 중단하여 그 결과를 되돌릴 수 없는데 취소하는 유일한 방법은 **보상 트랜잭션 (compensating transaction)**을 실행하는 것이다.

# 트랜잭션 동시성

 다수의 트랜잭션이 시스템에서 동시에 실행되도록 허용한다면

- **프로세서와 디스크 사용률을 증가시킬 수 있다**: 곧 트랜잭션의 처리량을 증가시킨다. 한 트랜잭션이 CPU를 사용하는 동안 다른 트랜잭션은 디스크에 쓰는 등의 일을 할 수 있다.
- **평균 응답 시간을 줄일 수 있다:** 짧은 트랜잭션이 긴 트랜잭션을 기다리지 않도록 할 수 있다.

### 동시성 제어 기법

 데이터베이스의 일관성을 깨는 것을 막기 위해 동시에 실행되는 트랜잭션 사이의 상호작용을 제어하는 매커니즘이다. 즉, 고립성을 보장한다.

### 스케줄

 동시에 실행되는 트랜잭션의 명령어들이 순서대로 기술된 일련의 명령어이다. 즉, 시스템에 실행중인 트랜잭션들의 어떤 순서에 따라 실행되는지를 보여준다. 스케줄은:

- 기술하고 있는 트랜잭션의 모든 명령어로 구성되어야만 하고
- 명령어는 각 개별 트랜잭션의 명령어 순서를 따라야 한다.

 실행을 성공적으로 마친 트랜잭션은 마지막 문장으로 커밋 명령어를 가져야 하고 실패한 트랜잭션은 마지막 문장으로 중단 명령어를 가져야만 한다.

### 동시성 제어 컴포넌트

 동시 수행을 제어하는 일이 전적으로 운영체제에게 주어져 있다면 데이터베이스를 비일관성 상태로 만드는 많은 스케줄이 있을 수 있다. 데이터베이스 시스템이 일관된 상태에 있도록 스케줄을 실행하는 것은 전적으로 데이터베이스 시스템의 몫이다. 

 이러한 역할을 수행하는 것은 데이터베이스 시스템의 동시성 제어 컴포넌트이다.

### 직렬 스케줄

 동시 수행한 스케줄의 결과가 하나씩 순차적으로 수행하는 스케줄의 실행 결과와 동일하도록 하여 데이터베이스의 일관성을 보장할 수 있다. 이렇게 동시 순차적으로 수행한 스케줄과 동일한 결과를 내놓는 동시 수행 스케줄을 **직렬(serializable) 스케줄**이라 한다.

# 직렬성

 각 트랜잭션이 데이터베이스의 일관성을 지켜줘야 하는 것은 기본이다. 따라서 여러 트랜잭션들의 각 단계가 교차 수행된다면 직렬성을 갖는지 확인해줘야 한다. 이와 관련한 두 가지 개념으로 충돌 직렬성과 뷰 직렬성이 있다.

### 충돌 직렬성 (Conflict serializability)

  

![Conflict Serializability](https://t1.daumcdn.net/cfile/tistory/9963F03C5C1600EA33)

 다음과 같이 한 트랜잭션의 명령어가 다른 트랜잭션의 연산에 영향을 줄때 충돌한다고 한다.

 위의 4가지 경우에서 I와 J가 둘 다 read 연산일 때에만 실행 순서와 상관이 없고 최소 하나의 write 연산이 있다면 서로 충돌한다. 물론 그림에도 나와있듯이 같은 데이터 항목에 대한 명령어만을 대상으로 한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9d8290ea-6923-4417-b884-0c4ffbd67d27/Untitled.png](https://t1.daumcdn.net/cfile/tistory/99A652405C16015806)

 스케줄 S와 S'에 대하여 만약 스케줄 S가 충돌이 일어나지 않는 명령어들의 순서를 바꿔서 스케줄 S'로 변경된다면 S와 S'가 **충돌 동등 (conflict equivalent)**하다고 할 수 있다. 

 충돌 동등 개념은 충돌 직렬성 (conflict serializability)라는 개념으로 확장된다. 만약 스케줄 S가 한 순차 스케줄에 충돌 동등하면 그 스케줄 S가 **충돌 직렬적(conflict serializable)**하다고 할 수 있다. 즉, 위의 스케줄3과 스케줄6은 충돌 직렬하다.

 예시 충돌 동등 과정:

 read(B)와 write(A) 순서 변경 → read(B)와 read(A) 순서 변경 → write(B)와 write(A) 순서 변경 → write(B)와 read(A) 순서 변경

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b6691c97-d0a1-463b-a2a6-03d30179d8d4/Untitled.png](https://t1.daumcdn.net/cfile/tistory/9962673A5C1601AC02)

 반면 $T_3$ 와 $T_4$는 순서를 바꿀 수 없기 때문에 충돌 직렬하지 않다.

# 충돌 직렬성 검사 알고리즘

 스케줄 S를 고려하자. S로부터는 **우선순위 그래프(precedence graph)**라고 하는 방향성 그래프를 생성할 수 있다. $G=(V,E)$에서 $V$는 그 스케줄에 들어있는 모든 트랜잭션들의 집합이고, $E$는 아래 세 가지 조건 중 하나를 만족하는 $T_i$→$T_j$인 모든 간선들의 집합이다.

1.  $T_j$가 read(Q)를 실행하기 전에   $T_i$가 write(Q)를 실행한다.
2.  $T_j$가 write(Q)를 실행하기 전에  $T_i$가 read(Q)를 실행한다.
3.  $T_j$가 write(Q)를 실행하기 전에  $T_i$가 write(Q)를 실행한다.

 만약 간선  $T_i$→$T_j$가 순위 그래프에 존재한다면 S에 일치하는 순차 스케줄 S'에서  $T_i$는 반드시  $T_j$보다 먼저 실행돼야 한다.

 스케줄을 순위 그래프로 나타냈을때 사이클이 있는 경우 그 스케줄은 충돌 직렬적인 스케줄이 아니다. 

 따라서 충돌 직렬성을 검사하기 위해서는 다음과 같은 알고리즘을 따른다.

1. 순위 그래프 만들고
2. 사이클 탐색 알고리즘 실행 (DFS로 실행시 $O(n^2)$의 연산 필요)

# 복구 가능한 스케줄

 다음과 같은 스케줄은 복구가 불가능하다.

 

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5e2c1478-6ee6-44b2-b271-2760591c857e/Untitled.png](https://t1.daumcdn.net/cfile/tistory/9948AC3A5C1602B505)

 $T_9$은 read(A)를 수행한 후 바로 커밋한다.  $T_9$는 $T_8$이 아직 동작중인 상황에서 커밋하는데 $T_8$이 커밋을하기 전에 실패했다고 하면 $T_9$는 $T_8$가 기록한 데이터 A를 이미 읽었기 때문에 종속적이고 $T_8$이 실패하여 원자성을 보장하기 위해서는 $T_9$를 취소해야 한다. 그러나 $T_9$는 이미 커밋되었고 취소할 수 없다. 이와 같은 스케줄을 복구 불가능하다고 한다.    

 이 스케줄이 복구 가능하기 위해서는 $T_9$는 $T_8$이 커밋할 때까지 커밋을 지연해야 한다. 

# 비연쇄적인 스케줄

 다음과 같은 스케줄을 생각하면

![https://t1.daumcdn.net/cfile/tistory/99890D335C15F65D29](https://t1.daumcdn.net/cfile/tistory/9904D54F5C16037406)

 하나의 트랜잭션이 취소됨으로써 다른 일련의 트랜잭션들이 따라서 취소되는 현상이 발생한다. 이와 같은 현상을 **연쇄적 롤백(cascading rollback)**이라고 한다.

 상당히 많은 양의 작업이 취소되기 때문에 연쇄적 롤백이 발생하지 않도록 스케줄에 제한을 두는데 이런 스케줄을 **비연쇄적인 스케줄(cascadeless schedule)**이라고 한다.

# 트랜잭션 고립성 수준

 고립성은 트랜잭션에서 중요하긴 하다. 하지만 실제 상황에서 중요하지 않은 부분들을 유연하게 처리하기 위해 고립성의 수준을 나눠 낮은 고립성을 할당하기도 한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a423ad11-b82b-4d88-bcef-a6013832987f/Untitled.png](https://t1.daumcdn.net/cfile/tistory/99F736425C1604C33B)

- **Serializable**: 직렬적 실행을 보장한다.
- **Repeatable Read**: 단지 커밋된 레코드만 읽을 수 있고 반복적으로 읽혀도 같은 값을 반환한다. 그러나 트랜잭션들은 직렬적이지 않을 수 있다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7b2c5716-965c-4c14-a04b-bc1608548050/Untitled.png](https://t1.daumcdn.net/cfile/tistory/99E513465C16075E1B)

- **Read Committed:** Dirty Read 를 허용하지 않는다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ff844368-a37e-46e7-b166-3437904f9e13/Untitled.png](https://t1.daumcdn.net/cfile/tistory/99B885465C16075E48)

 T1 중에 T2를 허용하지 않지만 Nonrepeatable read라 S1→T1→S2 순서로 실행 가능한데 동일한 쿼리지만 서로 다른 결과가 발생한다. 즉 직렬적이지 않은 스케줄이 발생가능하다.

- **Read Uncommited**: Dirty Read를 허용한다. Dirty Read란 Commit되지 않은 데이터 변ㄱ여을 읽을 수 있어서 직렬적이지 않은 결과가 나올 수 있다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4b263c25-fbc0-4f6b-a202-0535fecaaf75/Untitled.png](https://t1.daumcdn.net/cfile/tistory/995FD64F5C16058413)

 T1 수행중에 T2가 동시 수행 가능하다. 

# 고립성 수준의 구현

 

### 락킹

 트랜잭션의 락킹은 전체 데이터베이스가 아니라 사용해야할 데이터 항목만 락킹하면 된다. 성능을 보장하기 위해 락을 짧게 유지시키는게 핵심이다. 

 직렬성을 보장하기 위해 **2단계 락킹 규약**이라는 것이 있는데 간단하게 트랜잭션을 두 단계로 나누는 것이다.

- 한 단계는 락을 획득하기만하고 해제하지는 않는다.
- 두 번째 단계에서는 트랜잭션이 락을 해제하기만 하고 획득하지는 않는다. (실제로 해제되는 경우는 트랜잭션 수행이 커밋되거나 취소되는 등 수행이 종료되었을 때만 해당된다)

 두 종류의 락 (공유, 배타)을 사용하면 좀더 개선 가능하다.

- 공유 락: 트랜잭션이 데이터를 읽을 때 사용한다. 같은 항목에 대한 공유 락은 여러 트랜잭션이 동시에 획득할 수 있다.
- 배타 락: 트랜잭션이 데이터를 기록할 때 사용한다. 같은 항목에 대해 한 트랜잭션만 획득할 수 있다.

 위와 같은 구현 기법으로 데이터 항목에 대해 동시 읽기를 허용하며 직렬성을 보장한다.

### 타임스탬프

 각 트랜잭션에게 트랜잭션이 시작할 때의 **타임스탬프(timestamp)**를 부여한다. 각 데이터 항목에 대해 시스템은 두개의 타임스탬프를 유지하는데

- 읽기 타임스탬프는 그 데이터 항목을 읽은 트랜잭션의 타임스탬프 값 중 가장 큰 (최신의) 값을 갖는다.
- 쓰기 타임스탬프는 데이터 항목의 현재 값을 기록한 타임스탬프이다.

 타임스탬프는 트랜잭션의 데이터 항목에 대한 접근이 충돌될 때, 트랜잭션의 타임스탬프 순서로 접근하도록 한다. 이런 조정이 불가능하면 한 트랜잭션을 취소하고 새로운 타임스탬프로 재시작한다.

### 다중 버전과 스냅샷 고립

 데이터 항목에 대한 한개 이상의 버전을 유지함으로써 한 트랜잭션이 커밋하지 않은 다른 트랜잭션이나 직렬 순서 상 나중의 트랜잭션이 기록한 새 버전이 아닌 이전 버전을 읽게 할 수 있다.

 대표적으로 **스냅샷 고립 (snapshot isolation)**은 각 트랜잭션이 자기 자신만의 데이터베이스 버전을 갖고 있다고 생각할 수 있다. 데이터를 읽을 때 트랜잭션은 자기 자신만의 버전을 읽고 다른 트랜잭션이 갱신한 내용으로부터 고립된다.

 즉, 트랜잭션이 데이터베이스를 갱신하면 갱신은 실제 데이터베이스가 아니라 자기 자신의 버전에만 반영된다. 트랜잭션을 커밋할 때 갱신을 "실제" 데이터베이스에 적용하기 위해 갱신들에 대한 정보를 저장한다.

 트랜잭션 T가 부분 커밋 상태가 되면 T가 갱신하고자 하는 데이터를 다른 트랜잭션이 갱신하지 않았어야 커밋 상태가 된다. 커밋하지 못한 트랜잭션은 중단된다.

 스냅샷 고립의 가장 큰 특징은 읽기 트랜잭션은 절대로 대기되는 일이 없다. 대부분의 트랜잭션은 읽기 전용이기 때문에 락킹과 비교해 큰 성능향상을 볼 수 있다.

 단점도 존재하는데 너무 많은 스냅샷을 제공한다는 것이다. 서로 다른 두 트랜잭션에 대하여 서로가 각자 고립된 버전에서 갱신하기 때문에 서로의 수정된 데이터를 볼 수 없다. 이로 인해 직렬 수행에서는 발생하지 않는 비일관적 데이터베이스 상태의 가능성을 가지고 있다.