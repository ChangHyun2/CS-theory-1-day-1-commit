# Overview

 운영체제 메모리관리 부분의 설계는 다음 기본 선택 영역에 의존한다.

1. 가상메모리 기술을 사용할지 여부
2. 페이징, 세그먼테이션, 혹은 세그먼테이션/페이징 결합의 사용
3. 메모리 관리와 관련된 알고리즘

 1번과 2번 영역에서의 선택은 하드웨어 플랫폼에 의존한다. 따라서 운영체제의 가상메모리 제공 관련 기술은 기반 하드웨어 지원이 없을 경우 실용성이 없다. 하지만 최근 모든 주요 운영체제들이 가상메모리를 제원하고, 순수세그먼테이션 시스템은 거의 없어져 간다.

 세그먼테이션이 페이징과 결합될 경우, 시스템 설계자들이 직면하는 **메모리 관리 이슈 대부분이 페이징과 관련**된다.

 가상메모리 관리 정책에 있어 주요 이슈는 **성능**이다. → 페이지폴트가 초래하는 오버헤드가 매우 크기 때문. 가상메모리를 위한 운영체제의 정책은 다음과 같다.

- 반입정책 (Fetch Policy)
- 배치정책 (Placement Policy)
- 교체정책 (Replacement Policy)
- 적재집합 (Resident Set) 관리
- 클리닝정책 (Cleaning Policy)
- 부하제어 (Load Control)

 중요한 것은 어떤 영역과 관련해서도 최고의 정책은 없다. 페이징 환경에서 메모리 관리 작업은 엄청나게 복잡하기 때문에 최종 답안이 없다. 

 특정 정책 집합의 성능은 메인메모리의 크기, 메인메모리와 보조기억장치의 속도, 자원 경쟁 프로세스들의 크기나 수, 개별 프로그램의 수행 행태 등에 의존한다.

 시스템의 크기에 따라 시스템 관리자와 운영체제 설계자에게 책임이 따른다.

- 작은 시스템들의 경우 그 당시 알려진 상황들을 근거로 넓은 범위의 조건들에 대해 '좋을 것 같은' 정책들의 집합을 선택해야 한다.
- 큰 시스템들의 경우, 시스템 관리자에게 운영체제 모니터링 도구와 제어 도구를 제공하여, 실제 시스템 운영 환경에서 운영체제를 조율함으로써 '좋은 결과'가 산출될 수 있게 해야 한다.

# Operating System Software

## 반입정책 (Fetch Policy)

 각 페이지를 **언제** 메모리로 적재할지 결정하는 정책이다.

### 요구페이징 (Demand paging)

 페이지가 메모리로 반입되는 시점을 해당 페이지의 일부가 참조될 때로 한정한다. 요구페이징은 다음과 같은 상황이 전개될 것으로 예측하고 설계된 것이다: 프로세스가 생성되고 충분한 시간동안 수행되면 지역성의 원칙에 의해 대부분의 참조 대상은 최근에 반입된 페이지들이 될 것이라 예측한다.

→ 어느 정도의 시간이 지나 안정 상태가 되면 페이지폴트 회수는 매우 낮은 수준으로 떨어진다.

### 선페이징 (Prepaging)

 탐색시간, 회전 지연 등 디스크와 같은 대부분의 보조 기억장치들이 가진 특성을 이용하여 페이지폴트에 의해 요구된 페이지들 이외의 페이지들도 반입된다.

 한 프로세스의 페이지들이 보조기억장치에 연속적으로 저장되어 있다면 일련의 연속된 페이지들을 한꺼번에 반입하는 것이 효율적이라고 예측하지만 지금까지 선페이징의 유용성은 입증되지 못하고 있다.

---

## 배치정책 (Placement Policy)

 적재될 블록이 메인메모리의 **어디에** 위치할 것인지를 결정하는 정책이다.

 순수 세그먼테이션 시스템의 경우에 중요한 설계 이슈 (선택 대안: 최적적합, 최초적합 등)지만, 순수 페이징이나 세그먼테이션과 결합된 페이징을 사용하는 시스템의 경우, 일반적으로 배치는 문제가 되지 않는다.

 특별히 NUMA (Non-Uniform Memory Access) 구조의 다중처리기의 경우 각 페이지를 그것을 참조할 프로세서와 가까운 메모리 모듈에 배치하는 전략이 필요하긴 하다.

 

---

## 교체정책 (Replacement Policy)

 교체 정책은 여러 개념들과 관련되어 있고 이들 또한 서로 연계되어 있어 설명하기 어렵다.

- 활동 중인 프로세스에 얼마나 많은 프레임을 할당할 것인가
- 교체 페이지로 고려될 대상을, 페이지폴트를 발생시켜 페이지를 반입하게 한 프로세스의 페이지들로 한정할 것인가, 아니면 메인메모리 상의 모든 프레임으로 확대할 것인가
- 고려 대상 페이지들 중에 어떤 페이지를 교체 대상으로 선택할 것인가

 처음 두 개념은 **적재집합 관리** 면에서 더 관련이 있고, 세번째 개념을 집중적으로 **교체정책**과 관련하여 다룬다. 모든 교체정책은 교체되는 페이지가 **가까운 미래에 참조될 가능성이 적은 페이지**이어야 한다는 것을 목표로 한다.

 따라서 교체정책은 과거 행태를 근거로 미래의 행태를 예측하려 한다. 교체정책이 정교할수록 그 구현에 소요되는 HW나 SW 비용이 더 커진다는 점은 고려하여 절충해야 한다.

### 프레임 잠금 (Frame Locking)

 OS는 일부 페이지 프레임을 잠가 둘 수 있는데, 이는 해당 프레임에 적재된 페이지가 교체되지 않도록 표시해 두는 것이다. 잠금 기능은 프레임 테이블이나 페이지 테이블에 각 프레임과 연계된 **잠금 비트를 유지**하는 방식으로 구현될 수 있다. 

 실제로 주요 제어 구조를 비롯해 운영체제 커널 중 많은 부분이 잠긴 프레임에 유지되고 입출력 버퍼와 시간임계 영역 (time-critical areas) 등도 메모리의 프레임들에 잠가 둘 수 있다.

### 기본 알고리즘

- **최적 정책:** 미래에 참조될 때까지의 시간이 가장 긴 페이지를 교체 대상으로 선택한다.

     가장 이상적인 정책으로 가장 적은 페이지폴트를 발생시킨다. 하지만 운영체제가 미래에 일어날 사건들에 대해 완벽하게 알 수 없기 때문에 이 정책의 구현은 현실적으로 불가능하다.

    → 실제 구현 가능한 알고리즘들을 **평가하는 기준**이 된다.

- **LRU 정책**: 가장 오랫동안 참조되지 않은 메모리 상의 페이지를 교체한다.

     지역성의 원리에 따르면 가까운 미래에 참조될 가능성이 가장 적을 것으로 예상되는 페이지가 분명하지만 **구현이 어렵다**는 것이 문제다.

    1. 각 페이지에 대한 최종 참조 시간을 페이지의 태그로 설정한다.

         명령어나 데이터가 참조될 때마다 해당 페이지의 태그 값이 갱신되어야 하므로, HW 지원이 있다해도 오버헤드가 크다.

    2. 페이지 참조들에 대해 스택을 유지한다. → 마찬가지로 비용이 크다.
- **FIFO (First-in-first-out)**: 프로세스에 할당된 페이지프레임들을 순환버퍼처럼 다루어, 라운드로빈 스타일로 프레임 상의 페이지들을 제거한다.

     가장 오래 전에 반입된 페이지는 이제 사용되지 않을 것이라는 논리를 근거로 들지만 프로그램 수행 과정 내내 집중적으로 이용되는 코드나 데이터 영역이 존재해서 잘 맞지 않는다. 
    → 성능이 떨어진다.

     하지만 페이지들을 원형으로 연결하는 포인터만 있으면 구현이 가능하므로 간단하다.

- **클록 (Clock)**: 각 프레임에 대해 사용비트 (use bit)라는 한 비트를 연계하고 처음 반입될 때나 참조될 때마다 사용비트가 1로 설정된다.

    **구현**

    ---

    - 페이지를 적재한 프레임들이 환형으로 배치되어 있다고 간주하고, 첫 교체후보를 가리키는 포인트(시계바늘)를 설정한다.
    - 시계 방향으로 포인터를 이동시키면서 포인터가 가리키는 프레임 중 사용비트가 0인 첫 프레임 상의 페이지를 교체한다. 탐색 중에 사용비트가 1인 프렝미을 만나면 그 값을 0으로 바꾸고 다음 프레임으로 진행한다.
    - 사용비트가 1인 프레임을 건너뛴다는 점을 제외하면 FIFIO와 유사하다.

    **예시**

    ---

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/09d8422e-9cbc-4e6f-883f-a24cb1bf945d/Untitled.png](./virtual-memory/16.png)

**각 클록 정책의 행태**

---

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/86415788-f407-4cab-b453-33b6fc3cc265/Untitled.png](./virtual-memory/17.png)

**각 알고리즘 성능 비교**

---

 한 프로세스에 할당된 페이지프레임 수가 고정되어 있다고 가정, 256워드의 페이지 크기 사용:
FORTRAN 프로그램이 $0.25 \times 10^6$번 의 참조

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c5d437bb-a69a-48bd-becf-a72fa0472fe0/Untitled.png](./virtual-memory/18.png)

### 클록 알고리즘의 개선

 클록 알고리즘은 그것이 사용하는 비트 수가 증가함에 따라 보다 강력해질 수 있다. 한 예로 페이징에서 다루었던 변경비트가 메모리의 모든 프레임과 연계된다.

사용비트 u와 변경비트 m에 따라 4가지 경우를 생각할 수 있다.

- 최근에 참조되지 않았으며, 변경되지 않음 (u=0; m=0)
- 최근에 참조되었으며, 변경되지 않음 (u=1; m=0)
- 최근에 참조되지 않았으며, 변경됨 (u=0; m=1)
- 최근에 참조되지 않았으며, 변경되지 않음 (u=1; m=1)

 이를 기반으로 작동하는 방식은

1. 반입된 후 변경되지 않고 최근에 참조되지 않은 페이지 (u=0; m=0)를 찾아 버퍼 상의 모든 페이지들을 훑어가며 순환한다. 
2. 첫 번쨰 순환에서 그런 페이지를 찾지 못하면, 최근에 참조되지 않은 변경된 페이지 (u=0; m=1)를 찾아 페이지 버퍼를 다시 순환한다. 이때, 지나쳐 가는 모든 프레임의 사용비트를 0으로 설정한다.
3. 두 번째 순환에서 실패할 경우, 다시 단계 1과 2를 반복한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c759cecd-605b-4ad1-8f2f-4205fc7d8dea/Untitled.png](./virtual-memory/19.png)

### 페이지버퍼링(Page Buffering)

 LRU와 클록 정책이 FIFO보다 우수할지라도 두 정책은 모두 FIFO가 갖지 않은 복잡성과 오버헤드를 갖는다. 페이지버퍼링이 이 오버헤드를 해결해줄 수 있다.

 교체 대상으로 선택된 페이지를 즉시 교체하지 않고 가용페이지 리스트 뒤쪽에 연결시켜 어느 정도 기간 동안 메인메모리 상에 유지한다. 특히 변경된 페이지인 경우 변경페이지 리스트에 연결시킨다.

→ 페이지가 메인메모리 상에서 물리적으로 이동하는 것이 아니라, **해당 페이지에 대한 사상 정보**가 PTE로부터 제거되고 관련 정보가 가용페이지 리스트나 변경페이지 리스트에 연결된다.

 일정 범위의 가용페이지 수를 유지하고, 실제 새로운 페이지를 적재해야 할 때 가용페이지 리스트 상의 첫 페이지를 교체한다. → 변경페이지 리스트 상의 페이지가 디스크에 기록될 경우 가용페이지 리스트로 이동한다.

 **장점**

- 실제로 교체되기 이전에 참조될 경우 적은 비용으로 페이지폴트 해결 가능
- 변경페이지들에 대한 클러스터 입출력 가능 → 입출력 연산의 횟수와 디스크 접근 시간이 줄어든다.

---

## 적재집합 관리

### 적재집합의 크기

 운영체제는 얼마나 많은 페이지를 반입할지, 즉 프로세스에게 얼마나 많은 메모리를 할당할지 결정해야 한다. 고려해야할 인자들은 다음과 같다.

- 한 프로세스에게 할당된 메모리의 양이 적을수록, 임의 시점에 메모리에 존재 가능한 프로세스가 많아진다. → 스와핑으로 인한 시간적 손실 절감
- 메모리 상에 적재된 한 프로세스의 페이지 수가 상대적으로 작으면, 페이지폴트 발생률이 높아진다.
- 적재된 페이지 수가 어느 정도 이상이 되면, 해당 프로세스에게 메모리를 추가 할당하더라도 지역성의 원리에 의해 그 프로세스의 페이지폴트 발생률에 큰 영향이 없을 것이다.

 이러한 인자들을 고려하여 두 종류의 정책을 적용한다.

- **고정할당 (fixed allocation)**: 각 프로세스에게 고정 개수의 페이지프레임을 주고 수행시킨다.

     그 프레임 수는 초기 적재 시점(프로세스 생성 시점)에 결정되는데, 프로세스의 타입(대화식, 일괄처리식, 응용의 유형 등)이나 프로그래머 혹은 시스템 관리자의 지침 등이 결정의 근거가 된다.

- **가변할당 (variable-allocation)**: 프로세스 생존 기간 동안 각 프로세스에 할당된 페이지프레임 수의 변경을 허용한다.

     지속적으로 높은 수준의 페이지폴트 발생률을 보이고 있는 프로세스에게는 페이지프레임을 추가 할당하여 페이지폴트 발생률을 줄이고, 현저히 낮은 페이지폴트 발생률을 보이는 프로세스로부터는 페이지폴트 발생률이 크게 증가되지 않을 정도로 할당량을 줄인다.

### 교체범위

- **지역교체 정책 (local replacement policy):** 페이지폴트를 발생시킨 프로세스의 적재 페이지들 중에서 교체 대상 페이지를 선택한다.
- **전역교체 정책 (global replacement policy)**: 어떤 프로세스가 소유한 것인지에 상관없이 메모리 상의 잠기지 않은 모든 페이지를 교체 후보로 고려한다.

 교체범위와 적재집합의 크기 간에는 관련성이 있다. 고정된 적재집합은 지역교체 정책을 함축하는데, 이는 적재집합의 크기를 고정하려면 메모리에서 제거되는 페이지를 동일 프로세스의 또 다른 페이지로 교체해야 하기 때문이다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9afd561d-6746-4163-ace3-2b744da07cba/Untitled.png](./virtual-memory/20.png)

### 고정할당, 지역범위

 메모리 상에서 수행 중인 프로세스는 고정된 개수의 프레임을 가진다. 페이지폴트가 발생할 경우 OS는 해당 프로세스의 적재 페잊지들 중 한 페이지를 교체 대상으로 선택해야 한다. (앞서 설명한 교체정책과 통한다.)

고정할당 정책의 경우 한 프로세스에 대한 할당량을 미리 결정할 필요가 있으며, 응용의 타입이나 프로그램에 의해 요구된 수량 등이 그 근거가 될 수 있다. 하지만 취약점은 다음과 같다.

- 할당량이 너무 적을 경우, 높은 페이지폴트 발생률
- 할당량이 많아질 경우, 다중 프로그래밍의 차수가 적어져 처리기 유휴시간이나 스와핑 시간 증가

### 가변할당, 전역범위

 구현이 쉬워 많은 OS들에 의해 채택되었다.

구현 전략은

- OS가 가용프레임 리스트를 유지한다.
- 페이지폴트 발생시 해당 프로세스의 적재집합에 가용프레임을 추가한다.
- 가용프레임이 없을 경우, 잠긴 프레임 이외의 모든 프레임을 대상으로 교체 대상 페이지를 선택하여 교체한다. 문제는 어떤 프로세스를 선택하여 그 적재집합 중 한 페이지를 잃게 할 것인지 결정하는 규칙이 없어 → 적재집합의 크기가 줄어든 프로세스가 최적이 아닐 수 있다.

 잘못된 페이지 선택 문제 해소 방안으로 **페이지버퍼링**을 이용할 수 있다.

### 가변할당, 지역범위

 전역범위 전략의 문제점을 극복하기 위해 다음 방식을 사용한다.

- 새로운 프로세스가 메모리로 적재될 때, 응용의 타입이나 프로그램의 요구, 혹은 또 다른 척도들에 근거하여 어느 정도의 페이지프레임들을 적재집합으로 할당한다.
- 페이지폴트가 발생할 경우, 그것을 발생시킨 프로세스의 적재집합 중에서 교체할 페이지를 선택한다.
- 수시로, 프로세스에 대한 할당량을 재평가하고 전체적 성능 개선이라는 측면에서 **할당량을 증감**시킨다.

 가장 중요한 부분이 **적재집합 증감에 대한 결정**이며, 활성 프로세스의 미래를 평가하여 그것을 근거로 한다. 이 결정에 대한 대표적 전략들은 다음과 같다.

- **작업집합 전략 (Working Set Strategy)**

     진정한 작업집합 전략을 구현하기는 어렵지만, **비교 기준**으로서 검토할만 하다.

    특정 프로세스 (페이지 수 N)에 대한 **작업집합 $W(t, \Delta)$ 

    - 해당 프로세스가 가상시간 (매 가상주소 참조에 대해 1씩 증가) 상의 시점 $t-\Delta$ 부터 $t$ 까지 참조한 페이지들의 집합
    - $W(t,\Delta+1) \supseteq W(t,\Delta)$, $1\leq \left\vert W(t,\Delta) \right\vert \leq min(\Delta, N)$

      **작업집합 관리 방법**은

    1. 각 프로세스의 작업집합을 모니터링한다.
    2. 주기적으로 프로세스의 적재집합 중 작업집합에 있지 않은 페이지들을 제거한다. (기본적으로 LRU 정책)
    3. 프로세스는 메모리에 그 작업집합이 있을 때 (적재집합이 작업집합을 포함할 때)만 수행된다.

     하지만 **문제점**도 존재하는데

    - 과거가 항상 미래를 예측하지 않는다.
    - 정의에 충실하게 작업집합을 측정하는 것은 비현실적이다.
    - 최적의 $\Delta$ 값이 알려져 있지 않고 어떤 경우라도 가변적이다.

    **윈도우 크기에 따른 프로세스 Working Set 변화**

    ---

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e0e1c2ed-e635-4a9f-9767-59fc1baba250/Untitled.png](./virtual-memory/21.png)

    **작업집합 크기의 변화**

    ---

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f2c56aac-51ad-486a-8199-1591aa917935/Untitled.png](./virtual-memory/22.png)

- **PFF (Page Fault Frequency)**

     페이지 참조 시간을 추적하는 작업 집합 전략의 오버헤드를 해결하기 위해 페이지 참조 각각이 아니라 **페이지폴트 발생률**에 초점을 맞춘 전략이다.

     적재집합이 커질 때 해당 프로세스의 페이지폴트 발생률은 낮아진다. 이 적재집합과 페이지폴트 발생률의 관계를 근거로 작업집합을 직접 모니터링하지 않고 페이지폴트 발생률을 모니터링하여 유사한 결과를 얻는다.

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1e91143b-6557-4964-93b9-3d5fa97f96f7/Untitled.png](./virtual-memory/23.png)

    (b) 그래프 참조

    - 만약 한 프로세스의 페이지폴트 발생률이 최소 임계치보다 낮으면, 해당 프로세스에게 해를 끼치지 않고 (페이지폴트 횟수를 증가시키지 않고) 적재집합을 줄일 수 있어 시스템 전체적으로 이득 (다른 프로세스들을 위해 사용 가능한 페이지프레임 증가)을 얻을 수 있다.
    - 한 프로세스의 페이지폴트 발생률이 최대 임계치보다 높으면, 적재집합 크기를 증가시켜 해당 프로세스에게 유익을 주되 페이지폴트 발생이 줄어 시스템 성능이 떨어지지 않는다.

     이를 근거로 PFF 알고리즘은 메모리의 각 페이지와 연관된 **사용비트**를 설정하여 구현한다.

    - 사용비트를 해당 페이지가 참조될 때 1로 설정한다.
    - 페이지폴트 발생시 해당 프로세스가 직전에 페이지폴트를 발생시켰던 시점으로부터 경과된 **가상시간을 측정**한다.
    - 경과 시간이 (직전 페이지폴트 ~ 현재 페이지폴트) 정의된 임계치 F보다 작다면, 해당 프로세스의 적재집합에 한 페이지가 추가된다.
    - 그렇지 않다면 사용비트가 0인 모든 페이지가 버려져 적재집합이 그만큼 축소되며, 버려지지 않은 페이지의 사용비트는 모두 0으로 설정된다.

     하지만 새로운 지역성으로 전이해 가는 **과도 기간에 적재집합을 효과적으로 제어하지 못하**는 단점을 가지고 있다. 
    → 적재집합에 속한 어떤 페이지도 마지막으로 참조된 후 가상시간 F가 경과되기 이전에는 제거되지 않는다.
    → 지역성간 전이과정 동안, 수많은 페이지폴트로 옛 지역성에 의한 페이지들이 제거되기 전에 프로세스의 적재집합이 팽창한다.
    → 메모리 요구가 절정에 이르고, 불필요한 프로세스 비활성화 및 재활성화 작입이 유발된다.

- **VSWS (Variable-interval Sampled Working Set)**

     경과된 가상시간에 근거한 **샘플링**들을 통해 프로세스의 작업집합을 평가한다.

    - 샘플링 간격을 설정하여 샘플링 가간이 시작될 때 적재집합 내 모든 페이지의 사용비트를 0으로 설정하고, 샘플링 기간이 끝난 후 사용비트 0인 페이지를 제거한다.
    - 샘플링 기간 중 페이지폴트 발생시 새로운 페이지를 작업집합에 추가한다.
    - 페이지폴트 증가시 샘플링 간격을 줄여 사용되지 않은 페이지 제거를 가속화한다: 
    샘플링 기간 설정 인자 M(샘플링 간격의 최소 기간), L (샘플링 간격의 최대 기간), Q (샘플링 간에 발생이 허용된 페이지폴트의 회수) 사용

     샘플링 간격은 다음과 같이 설정한다.

    1. 최종 샘플링으로부터 경과된 가상시간이 L에 이르면, 프로세스를 보류시키고 사용비트를 살펴본다.
    2. 가상시간 L이 지나기 전에 Q개의 페이지폴트가 발생했을 때,
        - 최종 샘플링 이후 경과된 가상시간이 M보다 작으면, 경과된 가상시간이 M이 될 때까지 기다려 해당 프로세스를 보류시키고 사용비트를 살펴본다.
        - 최종 샘플링 이후 경과된 가상시간이 M보다 크거나 같으면, 프로세스를 보류시키고 사용비트들을 살펴본다.

     VSWS 알고리즘은 급작스런 지역성 간 전이로 메모리 요구가 절정에 이르는 상황을 해소하기 위해, 페이지폴트가 증가할 때 **샘플링 빈도 (사용되지 않은 페이지를 적재집합으로부터 제외시키는 속도)**를 높인다. → PFF만큼 구현도 쉽고 효과적이다.

    ## 클리닝 정책 (Cleaning Policy)

     변경된 페이지들 중 어떤 것을 보조기억장치에 기록할 것인지 결정하는 정책이다. → 반입정책과 상반됨

    - 요구클리닝 (demand cleaning): 교체 대상으로 선택되었을 때만 기록

         변경된 페이지의 기록 작업이 새로운 페이지의 반입 작업에 선행되어야 함
        → 페이지 기록은 최소화할 수 있지만, 페이지폴트를 발생시킨 프로세스가 블록에서 해제되기까지 **두 번의 페이지 전송을 기다려야 하며**, 이로인해 프로세서 활용도가 감소된다.

    - 선클리닝 (precleaning): 해당 페이지프레임이 요구되기 전에 변경된 페이지들을 기록 → 일괄처리

         일괄 기록하지만, 교체되기 전에 대부분 다시 변경될 수많은 페이지를 기록하는 것은 의미가 없다.

     두 정책 중 하나만 온전히 따르는 것은 위험하므로 **페이지버퍼링을** 접목하여 해결한다. → 변경 리스트와 비변경 리스트로 분리하여 관리

    - 변경된 페이지가 교체 후보로 선택되면 변경리스트에 연결시킨 후, 주기적으로 일괄 기록한 후 비변경리스트로 이동한다.
    - 새로운 페이지 반입 시, 비변경리스트 상의 프레임을 할당하여 적재한다.
    - (주기적으로) 기록되기 이전에 (운 좋게도) 참조될 경우 기록/적재 없이 재활용이 가능하다.
    - 페이지 교체 시 비변경리스트 상의 프레임을 이용하므로, 교체 당시 기존 페이지의 기록 작업은 없다.

    ## 부하제어 (Load Control)

     메모리에 적재될 프로세스의 수 (멀티프로그래밍의 수준)를 결정하는 것과 관련된다.

    - 메모리에 적재된 프로세스의 수가 너무 적으면, 프로세스 모두가 블록 상태가 되어 스와핑에 많은 시간이 소요되고
    - 메모리에 적재된 프로세스의 수가 너무 많으면, 각 프로세스의 **적재집합을 구성하는 평균 페이지 수가 불충분**해져 잦은 페이지폴트를 유발하게 되고, 궁극적으로 스레싱이 발생한다.

    ### 멀티프로그래밍 수준 (Multiprogramming Level)

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d8027610-e8e4-4f0c-8634-2f4c54a165e8/Untitled.png](./virtual-memory/24.png)

    - **작업집합/PFF 알고리즘**

         적재집합이 충분히 갖추어진 활성 프로세스만 수행을 허용하므로, 그 관리 과정에서 자동/동적으로 활성 프로세스의 수가 결정

    - $L=S$ **규범**

         폴트 간 평균 시간이 페이지폴트 처리에 필요한 평균 시간과 일치되도록 멀티프로그래밍 수준을 조절한다.

    - **50% 규범**

         페이징 장치의 활용도를 50%로 유지한다. → 처리기 활용도의 극대점임을 성능 연구 결과들이 보임

    - **클록 정책의 변형**

         환형 프레임 버퍼의 포인터가 얼마나 빨리 스캔하는지 그 속도에 대한 모니터링을 수반한다.  스캔 속도가 임계치보다 낮으면, 둘 중의 한 상황이다.

        - 페이지폴트가 거의 발생하지 않아 포인터 전진에 대한 요구가 거의 없다.
        - 각각의 요구에 대해 포인터로 스캔하는 평균 프레임 수가 적다는 것이며, 이는 참조되지 않아 간단히 교체 대상으로 선정할 수 있는 적재 페이지들이 많다.

         두 경우 모두 멀티 프로그래밍 수준을 안전하게 증가시킬 수 있다.

         반면, 포인터 스캔 속도가 상위 임계치를 넘으면, 페이지폴트 발생률이 높거나 교체 가능 페이지를 찾기 어렵다는 것이며, 이는 **멀티 프로그래밍의 수준이 너무 높다**는 것이다.

    ### 프로세스 보류 (Process Suspension)

     멀티 프로그래밍의 차수를 감소시키려면, 현재 적재된 프로세스들 중 하나 이상을 스왑-아웃시켜야 한다. 보류 대상으로 고려할 만한 프로세스는:

    - **최저 우선순위 프로세스**

         스케줄링 정책 결정을 구현한 것일 뿐, 성능 이슈와 관련이 없다.

    - **폴트 발생 프로세스**

         폴트를 발생시킨 프로세스가 그 작업집합을 적재하고 있지 못할 가능성이 크기 때문에 보류 당했을 때 손해도 최소가 될 것이라는 추론이다. (직접적 유익: 바로 블록될 프로세스를 블록시키는 것이므로, 페이지 교체나 입출력 비용 절감)

    - **가장 최근에 활성화된 프로세스**

        작업집합을 확보하고 있을 가능성이 가장 적은 프로세스이다.

    - **최소 적재집합을 가진 프로세스**

         미래의 재적재 비용을 최소화하지만, 지역성이 강한 프로세스에게 불리하다.

    - **가장 큰 프로세스**

        가장 많은 가용 프레임을 얻게하므로, 비활성화 작업에 대한 추가 수행의 필요성을 줄여준다.

    - **잔여 수행 윈도우가 가장 큰 프로세스**

         최소 처리시간 우선 (shortest-processing-time-first) 스케줄링 규칙과 유사하다.