# Overview

### Uniprogramming system

 메인 메모리를 두 파트로 나누는데, 운영체제가 사용하는 커널 공간과 사용자 프로그램이 실행되고 있는 나머지 공간이다. 

### Multiprogramming system

  다수의 프로그램이 하나의 메모리를 가지고 concurrent하게 실행되기 때문에 운영체제의 메모리 관리가 필수적인데 운영체제는 이때 단일 프로그래밍 시스템에서 나누었던 사용자 프로그램 공간을 더 나눈다.

 I/O 작업은 상당히 오래 걸리는 작업이기 대문에 프로세스 실행 시간의 대부분은 이 작업을 기다리는데 소요한다. 따라서 운영체제는 가능한한 많은 프로세스들이 프로세서에서 처리될 수 있도록 메모리를 적절히 할당하는 것이 메모리 관리의 최종 목표이다.

# Requiremets

### Relocation

  프로세서의 사용률 (Utilization rate)을 극대화하기 위해 프로세스는 디스크로 스왑인, 스왑아웃 된다. 하지만 처음 적재될 때 사용했던 똑같은 메모리 주소 공간을 그 다음 time-unit에 그대로 사용될 것이라는 보장이 없다. 따라서 다음에 스왑인 될 때는 메모리의 다른 공간으로 **재배치**할 필요가 있다.

 즉 프로그램이 적재되기 전에는 그 위치를 미리 알 수는 없고, 스와핑 시에 메인 메모리에서 프로그램 위치가 변경될 수 있도록 해야 한다.

### Protection

 프로세스는 다른 프로세스에 속한 프로그램들을  허가 없이 읽기나 쓰기를 위해 메모리 참조를 해서는 안 된다. 하지만 컴파일 시간에 어떤 메모리 주소가 다른 프로세스에 의해 사용되고 있는지 알 수는 없기 때문에 (앞서 다룬 재배치 문제나 동적 메모리 할당 등) 이 보호에 대한 요구사항을 만족시키기는 쉽지 않다.

 이를 해결하기 위해 한 프로세스가 생성하는 모든 메모리 참조가 오직 그 프로세스에게 할당된 메모리 공간만을 참조한다는 것을 **실행 시간에** 검사받아야 한다.

 예를 들어서 사용자 프로세스는 운영체제의 프로그램, 데이터 등 어떤 부분도 접근할 수 없다. 다시 말해 한 프로세스의 프로그램은 다른 프로세스의 명령어로 분기할 수도 없으며, 허가 없이 다른 프로세스의 데이터 영역을 접근할 수 없다. 만약 이런 상황이 발생하면 **프로세서(하드웨어)가** 그 명령어를 중단시켜야 한다.

### Sharing

 보호 메커니즘이 메인 메모리 내의 같은 부분을 접근하려는 여려 개의 프로세스들을 융통성 있게 허용할 수 있어야 한다.

 만약 여러 개의 프로세스들이 동일한 프로그램을 실행중이라면 각 프로세스들이 프로그램 사본을 각각 가지고 있는 것보다는 사본 하나를 가지고 모든 프로세스가 참조하도록 하는 것이 바람직하다.

### Logical organization

 일반적으로 메인 메모리는 연속적인 바이트나 워드로 이루어진 선형의 주소공간인데 프로그래머가 작성하는 프로그램들은 전혀 그렇지 않다. 대부분의 프로그램들은 모듈 단위로 구성되기 때문에 서로 일치하지 않는다. 또한 모듈별로 접근 권한이 다르게 주어지는 문제도 생긴다.

 따라서 운영체제와 컴퓨터 하드웨어는 모듈로 구성된 사용자 프로그램과 데이터를 효과적으로 처리할 수 있어야 한다. 이러한 요구사항을 충족시킬 솔루션으로 세그먼테이션 (Segmentation) 기법이 있다.

### Physical Organization

 컴퓨터 메모리는 주기억장치와 보조기억장치의 2-계층 아키텍처를 이룬다. 이러한 구조에서 시스템은 각 장치 사이의 정보 흐름을 어떻게 구성하느냐가 중요하다. 이러한 책임을 프로그래머에게 전가하는 것은 비현실적이다.

# Memory Partitioning

 메모리 관리의 주된 작업은 프로세서에 의해 실행될 프로세스를 메인 메모리로 가져오는 것이고, 궁극적인 목표는 프로세서 사용률을 극대화하는 것이다. 거의 모든 운영체제는 가상 메모리 기술을 사용하여 메모리 관리를 하는데 이 기술은 **세그먼테이션**과 **페이징** 기법에 기반을 둔다.

 우선 가상 메모리를 고려하지 않은 상태에서 페이징과 세그먼테이션에 대해 설명을 한다.

### Fixed Partitioning